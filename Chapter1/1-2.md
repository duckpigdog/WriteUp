# 0xGame 2020

## Misc

### flip（波形图 + 摩斯密码 + BinWalk + 倒序）

![](https://pic1.imgdb.cn/item/6919fce33203f7be000b18b6.png)

打开压缩包后得到一个 ZIP 和 MP3

![](https://pic1.imgdb.cn/item/6919fe603203f7be000b1909.png)

ZIP 需要密码，使用 Audacity 打开 MP3

![](https://pic1.imgdb.cn/item/6919fe353203f7be000b1903.png)

根据波形长短猜测是摩斯密码

```
....- ----- ----- ---.. ..... -.... -.... ----. ----. ...-- ----- ----- ... .. -.. .-. --- .-- ... ... .- .--.
```

解密得到

```
400856699300sidrowssap
```

翻译了一下题目题目名称有翻转的意思，把摩斯密码倒序发现:

```
passwordis003996658004
```

`003996658004` 即为压缩包密码

解压后还是压缩包

![](https://pic1.imgdb.cn/item/6919fec73203f7be000b1912.png)

使用 Kali 的 BinWalk 分离

![](https://pic1.imgdb.cn/item/6919fee23203f7be000b192d.png)

查看 `password.txt` 文件发现

```
?gnorw eb ot smees gnihtemos tub ,yranib ni elif etirw ot tnaw I

10100110

11010110

00101100

11000010

11111010

01100110

00001100

11111010

10100110

11000110

11001100

10010110

00001110

11111010

10000010

00000100

11001110

10010110

00000100

00100110

01001110

11110110

11101110

11001110

11001110

10000110

00001110

00000100

10100110

00010110

00101110

00000100

00110100

10101110

11110110

10011110

00000100

01001110

11110110

01100110

00000100

10100110

11010110

10000110

11000110

00000100

01100110

11110110

00000100

10100110

11000110

10100110

10010110

00001110

00000100

10000110

00000100

00101110

11001110

10101110

01010110

00000100

11001110

10010110

00000100

10110110

10100110

00110110

01000110

11110110

01001110

00001110

00000100

11001110

10010110

00010110

00101110

00000100

00101110

10000110

00010110

00101110

00000100

01001110

10100110

01101110

10100110

00110110

11000110

00000100

11110110

11001110

00000100

10100110

01001110

10000110

00000100

10101110

11110110

10011010
```

明显的倒序排列

将所有内容倒序后得到

```
01011001

01101111

01110101

00100000

01100001

01110010

01100101

00100000

01110011

01101111

00100000

01100011

01101100

01100101

01110110

01100101

01110010

00100000

01110100

01101000

01100001

01110100

00100000

01110100

01101000

01101001

01110011

00100000

01110000

01110010

01101111

01100010

01101100

01100101

01101101

00100000

01101001

01110011

00100000

01101010

01110101

01110011

01110100

00100000

01100001

00100000

01110000

01101001

01100101

01100011

01100101

00100000

01101111

01100110

00100000

01100011

01100001

01101011

01100101

00100000

01100110

01101111

01110010

00100000

01111001

01101111

01110101

00101100

00100000

01110100

01101000

01100101

00100000

01110000

01100001

01110011

01110011

01110111

01101111

01110010

01100100

00100000

01101001

01110011

00100000

01000001

01011111

01110000

01101001

00110011

01100011

01100101

01011111

00110000

01100110

01011111

01000011

00110100

01101011

01100101

I want to write file in binary, but something seems to be wrong?
```

二进制转十六进制再转 ASCII 码得到

```
You are so clever that this problem is just a piece of cake for you, the password is A_pi3ce_0f_C4ke
```

使用 `A_pi3ce_0f_C4ke` 密码提取出压缩包中的 `galf_si_siht.png`

提示我们打不开文件

![](https://pic1.imgdb.cn/item/6919ff5a3203f7be000b193f.png)

使用 010editor 打开该文件

发现文件头不是 PNG 格式

![](https://pic1.imgdb.cn/item/6919ff793203f7be000b194c.png)

拉到最底下发现还是倒序 **黄豆流汗脸.jpg** 

![](https://pic1.imgdb.cn/item/6919ff883203f7be000b1953.png)

将整个文件的十六进制倒序后保存为 PNG 图片打开发现二维码，使用二维码扫描工具得到

```
http://am473ur.com/0xgame/flip/bd055250d3906d1f791d8e83b4396893.php
```

访问拿到 flag（估计不在了）

### pacp（HTTP 流量 + PNG 宽高）

![](https://pic1.imgdb.cn/item/691a06463203f7be000b1add.png)

打开流量包发现是盲注流量

![](https://pic1.imgdb.cn/item/691a09e73203f7be000b1c36.png)

过滤 POST 请求发现有上传一个文件

```bash
http.request.method == POST
```

![](https://pic1.imgdb.cn/item/691a0a793203f7be000b1c49.png)

追踪 HTTP 流复制原始数据

![](https://pic1.imgdb.cn/item/691a11973203f7be000b2075.png)

用 WinHex 复制成新文件解压缩文件是一张图片，打开没内容，检查 CRC 发现宽高被更改过

![](https://pic1.imgdb.cn/item/691a0e853203f7be000b1eb6.png)

使用随波逐流梭哈出原图

![](https://pic1.imgdb.cn/item/691a11623203f7be000b2048.png)

### differentPic（图像合成）

![](https://pic1.imgdb.cn/item/691a15d43203f7be000b2311.png)

解压缩文件是两个一模一样的图片

![](https://pic1.imgdb.cn/item/691a15e83203f7be000b231d.png)

使用 StegSolve 打开选择 Image Combiner 模式（图像合成）

![](https://pic1.imgdb.cn/item/691a160e3203f7be000b234e.png)

发现可疑内容

![](https://pic1.imgdb.cn/item/691a16433203f7be000b2375.png)

保存后再打开切换通道发现是二维码

![](https://pic1.imgdb.cn/item/691a16943203f7be000b23b4.png)

扫码拿到 flag

![](https://pic1.imgdb.cn/item/691a16bb3203f7be000b23d9.png)

### extract（BinWalk + Stegpy）

![](https://pic1.imgdb.cn/item/691a18c53203f7be000b2528.png)

打开压缩包后发现图片

![](https://pic1.imgdb.cn/item/691a18dc3203f7be000b2534.png)

使用 BinWalk 检查发现有隐藏文件

![](https://pic1.imgdb.cn/item/691a18f03203f7be000b2549.png)

提取出二维码扫描给出提示工具 Stegpy

![](https://pic1.imgdb.cn/item/691a19133203f7be000b2556.png)

使用 Stegpy 成功拿到 flag

![](https://pic1.imgdb.cn/item/691a19453203f7be000b256b.png)

### easyMisc（拨号+ Stegpy）

![](https://pic1.imgdb.cn/item/691a80293203f7be000b99f0.png)

解压缩出三个文件

![](https://pic1.imgdb.cn/item/691a7ffa3203f7be000b97f5.png)

打开音频文件听着像是拨号声音，疑似拨号隐写

![](https://pic1.imgdb.cn/item/691a81333203f7be000ba677.png)

把频率设置为低频 697、高频 1633

![](https://pic1.imgdb.cn/item/691a817a3203f7be000ba9bd.png)

![](https://pic1.imgdb.cn/item/691a81843203f7be000baa20.png)

得到下图

![](https://pic1.imgdb.cn/item/691a819d3203f7be000bab00.png)

对照拨号隐写表格解密出：`2821876761`

![](https://pic1.imgdb.cn/item/691a816d3203f7be000ba922.png)

使用 `2821876761` 解压得到 flag 图片

再次使用 Stegpy 得到 flag

![](https://pic1.imgdb.cn/item/691a81ea3203f7be000baeb2.png)

### lowerBase64（Base64 隐写）

![](https://pic1.imgdb.cn/item/691aa9713203f7be000d4614.png)

**Base64字符串中的字母被随机转换了大小写**

正常的Base64解码器要求严格的大小写，所以我们需要找到正确的大小写组合

Base64 编码原理

```
# Base64 编码过程：
原文: 3 字节 = 24 bits → 分成 4 组，每组 6 bits → 每组映射为 1 个 Base64 字符
# 所以解码时需要以 4 个 Base64 字符为一组进行处理
```

由于我们不知道哪些字母应该是大写、哪些应该是小写，所以需要**暴力枚举所有可能的大小写组合**

```python
for i in range(0, len(c), 4):  # 以 4 个字符为一组处理
    pos = []
    chunk = c[i:i+4]  # 取出 4 个字符的块
    
    # 为每个字符创建可能的大小写组合
    for char in chunk:
        if char.isalpha():
            pos.append([char.lower(), char.upper()])  # 字母有两种可能
        else:
            pos.append([char])  # 非字母只有一种可能
    
    # 生成所有大小写组合
    cases = ["".join(k) for k in product(*pos)]
```

**举例说明**：

如果当前 chunk 是 `"AbC1"`，那么：

- `'A'` → `['a', 'A']`
- `'b'` → `['b', 'B']`
- `'C'` → `['c', 'C']`
- `'1'` → `['1']`

通过 `product(*pos)` 会生成：`"abc1", "abC1", "aBc1", "aBC1", "Abc1", "AbC1", "ABc1", "ABC1"` 共 8 种组合

最后验证结果

```python
for case in cases:
    try:
        decoded = b64decode(case)  # 尝试解码
        # 检查解码后的字符是否都在有效字符表中
        if all(chr(byte) in table for byte in decoded):
            real_data += case
            flag += decoded
            break  # 找到有效组合就跳出
    except:
        continue  # 解码失败就尝试下一个组合
```

![](https://pic1.imgdb.cn/item/691b2b563203f7be00107e6e.png)

### threeThousand（ZIP 爆破）

![](https://pic1.imgdb.cn/item/692bdfe0291f309b79e9000b.png)

第一次爆出密码是 33

![](https://pic1.imgdb.cn/item/692be0b4291f309b79e900da.png)

打开发现还有压缩包，且都是加密

![](https://pic1.imgdb.cn/item/692be0fc291f309b79e90599.png)

写脚本爆破

```python
import zipfile
import os
from itertools import product


def try_password(zip_file, password, target_dir):
    try:
        with zipfile.ZipFile(zip_file, 'r') as zip_ref:
            zip_ref.extractall(target_dir, pwd=password.encode('utf-8'))
        print(f"成功解压 {zip_file}，密码: {password}")
        return True
    except Exception as e:
        return False


def main():
    # 获取脚本所在目录
    script_dir = os.path.dirname(os.path.abspath(__file__))

    starting_zip = '2999.zip'
    # 目标解压目录也在同一目录下
    target_directory = os.path.join(script_dir, 'extracted_files')

    # 构建完整的文件路径
    current_zip = os.path.join(script_dir, starting_zip)

    # 确保目标目录存在
    if not os.path.exists(target_directory):
        os.makedirs(target_directory)
        print(f"创建解压目录: {target_directory}")

    # 生成所有可能的两位数密码组合
    passwords = [''.join(p) for p in product('0123456789', repeat=2)]
    print(f"生成的密码列表: {passwords}")
    print(f"脚本目录: {script_dir}")
    print(f"当前处理的文件: {current_zip}")
    print(f"目标解压目录: {target_directory}")

    while True:
        # 检查当前zip文件是否存在
        if not os.path.exists(current_zip):
            print(f'文件 {current_zip} 不存在，停止解压缩。')
            break

        print(f"正在尝试解压: {os.path.basename(current_zip)}")
        password_found = False

        for password in passwords:
            if try_password(current_zip, password, target_directory):
                print(f'成功使用密码 {password} 解压文件 {os.path.basename(current_zip)}！')
                password_found = True
                break

        if not password_found:
            print(f'无法为 {os.path.basename(current_zip)} 找到密码，停止解压缩。')
            break

        # 获取当前文件名（不含路径）
        current_filename = os.path.basename(current_zip)
        # 提取数字并减1
        next_zip_number = int(current_filename.split('.')[0]) - 1
        # 下一个文件应该在目标目录中
        current_zip = os.path.join(target_directory, f'{next_zip_number}.zip')

        print(f"下一个要解压的文件: {os.path.basename(current_zip)}")


if __name__ == "__main__":
    main()
```

![](https://pic1.imgdb.cn/item/692bf746291f309b79e94883.png)

## Crypto

### Calendar（日期网格坐标密码）

![](https://pic1.imgdb.cn/item/691b31bd3203f7be0010816c.png)

题目给出了一张图片

![](https://pic1.imgdb.cn/item/691b31cb3203f7be0010816f.png)

以及一段字符

```
SAT1,THU1,MON3,MON2,WED3,SUN2,THU1,SUN4,FRI3,THU1,MON4,MON4,FRI4,THU3,SUN4,SUN2,TUE4,THU1,FRI1,MON3,MON2
```

观察最后的数字只有 `1~4`，推测这就是行号，而字符就是对应的列

将得到的数字按照字母表的顺序转换最后得到

```
0xGame{calendarpasswordtable}
```

### easyXor（异或加密）

![](https://pic1.imgdb.cn/item/691b35853203f7be0010833b.png)

**连续两次异或同一个数结果不变**

```python
cipher = [72, 63, 38, 12, 8, 30, 30, 6, 82, 4, 84, 88, 92, 7, 79, 29, 8, 90, 85, 26, 25, 87, 80, 10, 20, 20, 9, 4, 80, 73, 31, 5, 82, 0, 1, 92, 0, 0, 94, 81, 4, 85, 27, 35]
flag = ""
cipher += [ord("^")]
for i in range(len(cipher)-1):
    flag = chr(cipher[len(cipher) - i - 2] ^ cipher[len(cipher) - i - 1]) + flag
    cipher[len(cipher) - i - 2] = ord(flag[0])
print(flag)
# 0xGame{ec15a9eb-08b7-4c39-904d-27eed888f73f}
```

### supperAffine（仿射加密变种）

![](https://pic1.imgdb.cn/item/691e12f33203f7be0018c793.png)

解题技巧先放前面：

1. **识别密码体制：** 代码中出现了 `affine(x, a, b)` 和 `GCD(MOD, ...)`，立即锁定这是**仿射密码**及其变种
2. **识别模数：** 立即进行**模数分解**，MOD = 62 = 2 * 31
3. **代数化简：**看到 `f3(f2(f1(x)))` 这种结构，立即意识到这是可以合并的

给出源代码

```python
from Crypto.Util.number import *
from string import ascii_letters, digits
from random import randint
from secret import flag

assert flag.startswith("0xGame{") and flag.endswith("}")
table = ascii_letters+digits
MOD = len(table)

def affine(x, a, b): return a*x+b

def genKey():
    a = [randint(1, 64) for _ in range(3)]
    b = [randint(1, 64) for _ in range(3)]
    while GCD(MOD, a[0]*a[1]*a[2]) != 1:
        a = [randint(1, 64) for _ in range(3)]
    return a, b


cipher = ""
A, B = genKey()
for i in flag:
    if i not in table:
        cipher += i
    else:
        cipher += table[affine(affine(affine(table.find(i),A[0], B[0]), A[1], B[1]), A[2], B[2]) % MOD]

print("cipher =", cipher)
# cipher = t6b7Tn{2GByBZBB-aan2-JRWn-GnZB-Jyf7a722ffnZ}
```

**📜 仿射加密原理简述**

仿射加密是一种非常基础的单表替代密码，它建立在凯撒密码的基础上，但引入了一个乘法因子，使其比凯撒密码更复杂一些

**1. 核心数学公式**

仿射加密的加解密过程都基于模运算

假设：

- x：明文字符在字母表中的位置（索引）
- y：密文字符在字母表中的位置（索引）
- m：字母表的大小（即模数，例如英文字母表 m=26）
- K_a 和 K_b：密钥，其中 K_a 是乘法密钥， K_b 是加法密钥

![](https://pic1.imgdb.cn/item/691e23d23203f7be0018c916.png)

| **过程** | **公式**                          |
| -------- | --------------------------------- |
| 加密     | E(x) = (K_a * x + K_b) MOD m      |
| 解密     | D(y) = K_a^{-1} * (y - K_b) MOD m |

**2. 密钥要求 (Key Requirement)**

为了确保加密过程是**可逆的**（即能够唯一解密）：

1. **乘法密钥 K_a 必须与模数 m 互质**
   - 数学表示为：GCD(K_a, m) = 1
   - 只有 K_a 与 m 互质，才能保证 K_a 在模 m 意义下存在逆元 K_a^{-1}（在解密公式中使用）
2. **加法密钥 K_b 可以是任意整数，通常选择在 [0, m-1] 范围内**

**3. 实际操作示例（以英文字母表 m=26 为例）**

1. **字母表映射：** 将 A 映射到 0，B 映射到 1，... Z 映射到 25。
2. **选择密钥：** 假设 m=26，我们选择 K_a=5（因为 GCD(5, 26) = 1）和 K_b=8
3. **加密 'C'：**
   - 'C' 的索引 x=2
   - E(2) = (5 * 2 + 8)(MOD 26) = 18 (MOD 26)
   - 索引 18 对应字母 'S'。因此，'C' 被加密成 'S'

现在再来解析源代码，**第一步构建字符集**

```python
# ascii_letters 包含 'a-z' (26) 和 'A-Z' (26)，digits 包含 '0-9' (10)
from string import ascii_letters, digits
table = ascii_letters+digits
MOD = len(table)	# MOD = 26 +26 + 10 = 62
```

**第二步定义仿射加密函数**

```python
def affine(x, a, b): return a*x+b
```

**第三步定义密钥生成函数**

```python
def genKey():
    # 随机生成三个乘法系数 (A[0], A[1], A[2])，范围 [1, 64]
    a = [randint(1, 64) for _ in range(3)]
    # 随机生成三个加法系数 (B[0], B[1], B[2])，范围 [1, 64]
    b = [randint(1, 64) for _ in range(3)]
    
    # 关键检查：确保乘法系数的乘积与模数 62 互质 (Coprime)
    # GCD(62, A_total) == 1 是仿射密码可逆（可解密）的必要条件
    while GCD(MOD, a[0] * a[1] * a[2]) != 1:
        a = [randint(1, 64) for _ in range(3)]
    return a, b
```

我们对模数 62 进行素因数分解：62 = 2 * 31

**互质的定义：** 两个数互质，意味着它们除了 1 以外，没有其他的公因数

因此，要让 k_a 与 62 互质，k_a 绝对不能包含 62 的任何因数

所以 `a[i]` 不能是偶数，也不能是 31 的倍数

**第四步加密**

```python
for i in flag:
    # 如果字符不在表中（例如 '{', '}', '-', '_'），则不加密，直接保留
    if i not in table:
        cipher += i
    else:
        # 核心加密逻辑：嵌套三次仿射变换
        # 设 x 为字符 i 在 table 中的索引
        # Step 1: y1 = A[0]x + B[0]
        # Step 2: y2 = A[1]y1 + B[1]
        # Step 3: y3 = A[2]y2 + B[2]
        # Final:  cipher_char_index = y3 % MOD
        
        # 原始代码写得比较紧凑，逻辑展开如下：
        idx = table.find(i)
        step1 = affine(idx, A[0], B[0])
        step2 = affine(step1, A[1], B[1])
        step3 = affine(step2, A[2], B[2])
        
        # 查表替换
        cipher += table[step3 % MOD]
```

转换成数学公式
$$
\begin{aligned}
&f(x)\ =\ A_3(A_2(A_1\ *\ x\ +\ B_1)\ +\ B_2)\ +\ B_3\\
&f(x)\ =\ A_3([A_2A_1\ *\ x\ +\ B_1A_2]\ +\ B_2)\ +\ B_3\\
&f(x)\ =\ A_3(A_2A_1\ *\ x)\ +\ A_3(B_1A_2)\ +\ B_2A_3\ +\ B_3\\\\
&K_a\ =\ A_1A_2A_3,K_b\ =\ A_3(B_1A_2)\ +\ B_2A_3\ +\ B_3\\\\
&f(x)\ =\ K_a\ *\ x\ +\ K_b
\end{aligned}
$$
**模数的等效性**

在模运算中，如果两个整数除以同一个模数 M 得到的余数相同，那么它们在模 M 的意义下是**等效的**（或**同余的**）

模数 MOD = 62，这就好比一个只有 62 个刻度的时钟

如果你转了 1 圈（62格），指针回到原点（0）

如果你转了 65 格，指针停在 3 的位置。**所以在模 62 的世界里，65 和 3 是完全等价的**

虽然题目生成密钥时使用了三个密钥，且他们乘起来可能非常大

但在上面我们化简的结果中，有效的 A 只有 **A_total (MOD 62)** 的结果，有效的 B 只有 **B_total (MOD 62)** 的结果

无论原始参数多复杂、数值多大，最终起作用的有效密钥 (A,B) 必定落在 [0, 61] 这个范围内。因此，我们不需要去猜原始的那 6 个随机数，只需要暴力枚举 0 到 61 之间的数，就能找到那个**等效密钥**

```python
from Crypto.Util.number import *
from string import ascii_letters, digits

table = ascii_letters + digits
cipher = "t6b7Tn{2GByBZBB-aan2-JRWn-GnZB-Jyf7a722ffnZ}"
MOD = len(table)


def find_ab():
    # 遍历所有可能的有效 A (0-61)
    for a in range(MOD):
        # 遍历所有可能的有效 B (0-61)
        for b in range(MOD):
            # 验证逻辑：
            # 我们知道 flag 开头是 "0xGame{"
            # 我们知道密文 cipher 开头是 "t6b7Tn"
            
            # 检查 1: 明文 '0' 能否加密成 密文 't'?
            if (a * table.find("0") + b) % MOD == table.find(cipher[0]):
                # 检查 2: 明文 'x' 能否加密成 密文 '6'?
                if (a * table.find("x") + b) % MOD == table.find(cipher[1]):
                    # ... 继续检查 'G' -> 'b', 'a' -> '7'
                    # 如果这四个字符都匹配上了，说明我们找到了正确的等效密钥 (a, b)
                    print("a, b = {}, {}".format(a, b))
                    return (a, b)


flag = ""
A, B = find_ab() # 获取找到的等效密钥
for i in cipher:
    if i not in table:
        flag += i # 特殊字符直接保留
    else:
        # 仿射解密公式：D(y) = inverse(A) * (y - B) % MOD
        # inverse(A, MOD) 是求 A 在模 MOD 下的乘法逆元
        flag += table[inverse(A, MOD) * (table.find(i) - B) % MOD]
```

### equationSet（提公因数 p 构造简易方程）

![](https://pic1.imgdb.cn/item/691e91d73203f7be001921a0.png)

解题技巧先放前面：

1. **符号化：**所有给出的数值用**数学符号**表示出来，并建立它们之间的关系
2. **寻找公因数：**如果给出的两个大数 A 和 B 都是由**相同的素数因子**构成的，那么 GCD(A, B) 往往是解密的关键
3. **确定解题路径：**一旦 p 被分解出来，接下来就要想方设法得到 q 和 r 的信息

题目给出代码

```python
from Crypto.Util.number import *
from secret import flag

e = 65537
m = bytes_to_long(flag.encode())
p, q, r = getPrime(512), getPrime(512), getPrime(512)

n = p*q*r
c = pow(m, e, n)
print(c)
print(n)
print(p+q+r)
print(p*q+p*r)
```

转换成数学公式
$$
\begin{aligned}
&n\ =\ p\ *\ q\ *\ r\\
&t\ =\ p\ *\ q\ +\ p\ *\ r\ =\ p(q\ +\ r)\\
&ϕ(n)\ =\ (p\ -\ 1)(q\ -\ 1)(r\ -\ 1)
\end{aligned}
$$
我们可以清楚地看到，**p 是 n 和 t 的公共因子**

那 GCD(n, t) 会正好是 p 吗？会不会包含其他因子？
$$
\begin{aligned}
&GCD(pqr,p(q\ +\ r))\ =\ p\ *\ GCD(qr,q\ +\ r)
\end{aligned}
$$
由于 q 和 r 都是生成的 512 位随机大素数，它们互质，且它们的和 q+r 极大概率与它们的积 qr 互质

因此 GCD(qr, q+r) = 1

**结论：** 直接计算 GCD(n, t) 就能无痛提取出素数 p

对于 n=pqr，欧拉函数定义为：
$$
\begin{aligned}
&\phi(n)\ =\ (p-1)(q-1)(r-1)\\\\
&\phi(n)\ =\ (p-1)\ *\ [(q-1)(r-1)]\\\\
&n\ -\ t\ =\ pqr\ -\ pq\ - \ pr\\
&n\ -\ t\ =\ p(qr\ -\ q\ - \ r)\\
&(n\ -\ t)\ //\ p\ =\ (qr\ -\ q\ - \ r)\\
&(n\ -\ t)\ //\ p\ +\ 1\ =\ (qr\ -\ q\ - \ r)\ +\ 1\\\\
&qr\ -\ q\ - \ r\ +\ 1\ =\ q(r\ -\ 1)\ -\ 1(r\ -\ 1)\\
&q(r\ -\ 1)\ -\ 1(r\ -\ 1)\ =\ (q\ -\ 1)(r\ -\ 1)\\\\
&(n\ -\ t)\ //\ p\ +\ 1\ =\ (q\ -\ 1)(r\ -\ 1)\\
&\phi(n)\ =\ (p-1)\ *\ [(q-1)(r-1)]\\
&\phi(n)\ =\ (p-1)\ *\ [(n\ -\ t)\ //\ p\ +\ 1]\\
\end{aligned}
$$
**观察公因数** 是 Crypto 选手的直觉。看到 n 和 t 有明显的公共结构（都含有 p），第一时间想到的就是 GCD

```python
from Crypto.Util.number import *

# ==========================================
# 题目信息与数学关系回顾
# ------------------------------------------
# 已知：
# n = p * q * r  (三素数 RSA)
# s = p + q + r  (此变量在本脚本中未被使用)
# t = p * q + p * r = p * (q + r)
# ==========================================

# 题目给出的长整数数据（省略部分以保持整洁）
c = 216719040256186298397028655750064798850... 
n = 894056034566447301955142597300391580123...
t = 157435908314881832180551915807491465031...

# [第一步]：提取公共素因子 p
# 数学原理：n = p*q*r，t = p*(q+r)
# 显然 p 是 n 和 t 的最大公约数
p = GCD(n, t)

# [第二步]：巧妙构造欧拉函数 phi(n)
# 目标：phi = (p-1) * (q-1) * (r-1)
# 
# 1. 括号右边推导：((n - t) // p + 1)
#    分子：n - t = pqr - (pq + pr) = pqr - pq - pr = p(qr - q - r)
#    除法：(n - t) // p = qr - q - r
#    加一：qr - q - r + 1
#    因式分解：q(r-1) - 1(r-1) = (q-1)(r-1)
#
# 2. 最终合并：
#    (p-1) * [(q-1)(r-1)] = phi(n)
phi = (p - 1) * ((n - t) // p + 1)

# [第三步]：常规 RSA 私钥计算
# 计算 e 在模 phi 下的乘法逆元 d
d = inverse(65537, phi)

# [第四步]：解密
# m = c^d mod n
m = pow(c, d, n)

# 将解密出的长整数转换为字节串（即明文 Flag）
print(long_to_bytes(m))
```

### Fibonacci（爆破斐波那契数列周期）

![](https://pic1.imgdb.cn/item/692a793127638c120a3c173a.png)

解题技巧先放前面：

1. **识别计算陷阱与核心矛盾：**看到一个天文数字立即判定这是**计算陷阱**
2. **建立 Pisano 周期的知识框架：**了解周期的基本性质
3. **掌握求和公式的转化：**一旦找到周期和周期和，必须将求和公式转换为可计算的代数形式
4. **大数运算：**CTF 中处理超大数论运算，首选 `gmpy2` 库

题目代码如下

```python
from Crypto.Util.number import *
from gmpy2 import next_prime
from functools import reduce
from secret import flag


def F(x):
    if x == 1 or x == 2:
        return 1
    return F(x-1)+F(x-2)


n = reduce(lambda a, b: a*b, [getPrime(4) for _ in range(4)])
r = getRandomNBitInteger(67)
S = sum([F(i) % n for i in range(r)])
p = next_prime(S**16)
q = getPrime(p.bit_length())
m = bytes_to_long(flag)
c = pow(m, 65537, p*q)

print("r =", r)
print("n =", n)
print("c =", c)
print("N =", p*q)
```

现在分析代码

定义了一个斐波那契数列

```python
def F(x):
    if x == 1 or x == 2:
        return 1
    # 递归定义，计算量巨大，但由于模运算，实际计算只需在一个周期内完成
    return F(x-1) + F(x-2)
```

斐波那契数列是一个**递推数列**，它的核心规则是：**从第三项起，数列中的每一项都等于前两项之和**
$$
\begin{aligned}
&F_n\ =\ F_{n-1}\ +\ F_{n-2}\ (n \geq 3)
\end{aligned}
$$
在 CTF 和数论领域，斐波那契数列的**模运算性质**至关重要：

**Pisano 周期**

- **定义：** 斐波那契数列对任何正整数 n 取模后，都会变成一个**循环数列**。这个循环的长度就被称为 **Pisano 周期**，记作
  $$
  \begin{aligned}
  &\pi(n)
  \end{aligned}
  $$

小模数 n 的生成

```python
# 2. 小模数 n 的生成
# 生成 4 个 4-bit 的小素数（p_i <= 15）
# n 是这四个小素数的乘积
# n 的大小约为 16 bits (n <= 15^4 = 50625)
n = reduce(lambda a, b: a*b, [getPrime(4) for _ in range(4)])
```

巨大的求和上限 r

```python
# 3. 巨大的求和上限 r
# r 是一个 67-bit 的大整数 (r 约等于 2^67)
# 注意：r 是计算 S 的唯一输入，且 r 已经泄露给我们
r = getRandomNBitInteger(67)
```

S 的计算

```python
# 4. 关键泄露信息 S 的计算 (S是 p 的基础)
# S 是前 r 个斐波那契数在模 n 下的和：S = Sum_{i=0}^{r-1} (F(i) mod n)
S = sum([F(i) % n for i in range(r)])
```

生成巨大的素数 p

```python
# 5. 生成巨大的素数 p
# p 是 S^16 之后的第一个素数
# S 的大小约为 r * n (约 2^67 * 2^16 = 2^83)
# p 的大小约为 (2^83)^16 = 2^1328 bits
p = next_prime(S**16)
```

生成素数 q

```python
# 6. 生成素数 q
# q 是一个与 p 相同长度的素数 (q 约 1328 bits)
q = getPrime(p.bit_length())
```

首先要求出 p -> S -> r 这个顺序

先看 S 的计算方式
$$
\begin{aligned}
&S\ =\ \sum_{i-0}^{r-1}{F((i)\ \ (mod\ n))}
\end{aligned}
$$
求和次数 r 太大，但是，求和时使用的模数 **n 却非常小**（不到 65536）

这是整个解题的关键步骤。我们不能循环 r 次，但 n 很小，所以我们要找规律

**Pisano 周期（重复的舞蹈）**

当斐波那契数列对一个小数字 n 取模时，它的结果会不断重复，形成一个**循环**。这个循环的长度就是 **Pisano 周期 T**

- 斐波那契数列 mod n 就像一个**舞者**在一个很小的圆形舞台（模数 n）上跳舞。它跳了一段时间后，姿势和位置一定会回到起点 (1, 1)
- **周期 T** 就是这支舞完整跳完一次所需要的步数

通过脚本实现

```python
a, b = 1, 1
while True:
    a, b = b, (a + b) % n # 找到下一步的舞步
    if a == 1 and b == 1: # 检查是否回到起点
        T = period = len(fibs) # 记录步数 T
        break
```

因为 n 很小，这个循环很快就能结束，我们得到了周期 T 和跳一圈舞的总得分 Sum_{cycle}

现在我们有了舞蹈的规律，就可以计算 r 步的总得分 S：

- **完整周期数 k：** k = r // T （看看 r 步能跳多少次完整的舞）
- **剩余步数 rem：** rem = r \% T （最后多出来没跳完的几步）

$$
\begin{aligned}
&S\ =\ (完整次数\ k\ *\ 一圈的总得分\ Sum_{cycle})\ +\ (剩余几步的得分\ Sum_{cycle})
\end{aligned}
$$

这一步就将天文数字 r 转换成了一个可计算的公式，得到了我们想要的秘密蓝图 S

| **脚本代码**              | **作用**                                                     | **简单理解** |
| ------------------------- | ------------------------------------------------------------ | ------------ |
| `p = next_prime(S ** 16)` | **计算第一个秘密零件 p。** 严格按照题目的公式，找到 S^{16} 之后的第一个素数 |              |
| `q = N // p`              | **计算第二个秘密零件 q。** N 是 p 和 q 的乘积，所以 q = N / p |              |
| `phi = (p - 1) * (q - 1)` | **计算制造蓝图 \phi(N)**                                     |              |
| `d = inverse(65537, phi)` | **计算万能钥匙 d。** `inverse` 是求一个数在 \pmod{phi} 世界里的“倒数” |              |
| `m = pow(c, d, N)`        | **解密！** 使用万能钥匙 d 打开保险箱 N 中的密文 c            |              |
| `long_to_bytes(m)`        | 将解密得到的数字 m 转换回 Flag 文本                          |              |

完整代码如下

```python
from Crypto.Util.number import *
import gmpy2

# ==========================================
# 1. 在此填入题目给出的参数 (从你的题目输出中复制)
# ==========================================
r = 6799657976717333  # 题目给出的 r (67-bit integer)
n = 34969  # 题目给出的 n (小整数，约 16-bit)
c = 182306974283951620352146026941583994848813143690343545292100780435573376889099600153592983212384957591086328477660614034391593564733860826251499298995355977799109267846836211477797049861348446512705981010295182077777939692478140339301301250656211795668782349225298841295102744088295274299888068087536135862146848855194234931032258224223054120694400807261402442809227521150204434199401928373883267697928229945582110688115412960868921538084717338343966490113059627708880297277412143561561837953806960309840302665509500602335832680764801782789278492075478763944213005349707521471401389317139473794212210077629296628421658105048387207038261321205  # 题目给出的密文 c
N = 1885611999537620305525377668936000019248252379006235038175895811710218489750248037027959751027236326639084060685909621893589756343903429224938045802850975926055076789137326688384533999739909152386986919824268841500802585809839133132715892685629871188263336038221503698167753853207939360629026179572549702198037779413041272313618794196167670066872427987596564652249864272782397242041014605617282098654595635031878004275878165728021995744626212185694275937448739806439006047047376363093018124169182873374456718929377731991273039952515054850718253257895996999907977029169396644305213162133388169761391593110121229266422245167572929912914529689341  # 题目给出的公钥 N


# ==========================================
# 2. 核心函数：寻找 Pisano 周期并计算周期和
#    对应思路 2 的优化版：直接在 Python 中实现
# ==========================================
def get_pisano_info(n):
    # 斐波那契数列缓存，用于计算余数部分的和
    fibs = [1, 1]

    # 寻找周期：暴力迭代直到再次出现 "1, 1"
    # 因为 n 很小，这个循环会很快结束
    a, b = 1, 1
    period = 0

    while True:
        # 下一项 F(i) = F(i-1) + F(i-2)
        a, b = b, (a + b) % n
        fibs.append(b)

        # 检查是否回到了起点 (1, 1)
        # 注意：现在的 b 是新的一项，a 是上一项
        if a == 1 and b == 1:
            # 找到了循环节！
            # 此时 fibs 最后两个是 1, 1，属于下一个周期的开始，要去掉
            fibs.pop()
            fibs.pop()
            period = len(fibs)
            break

    period_sum = sum(fibs)
    return period, period_sum, fibs


print(f"[*] Analyzing Pisano period for n = {n}...")
period, period_sum, fibs = get_pisano_info(n)
print(f"[+] Period found: T = {period}")
print(f"[+] Sum of one period: {period_sum}")

# ==========================================
# 3. 计算 S
#    利用公式：S = (完整周期的次数 * 周期和) + (剩余部分的和)
# ==========================================
k = r // period  # 完整的周期数
rem = r % period  # 剩余的项数

# 剩余部分的和 = 前 rem 项之和
rem_sum = sum(fibs[:rem])

# 计算最终的 S (注意题目中 S 是模 n 后求和，不需要再对 S 取模)
S = k * period_sum + rem_sum
print(f"[+] Calculated S = {S}")

# ==========================================
# 4. 恢复 RSA 密钥 p, q
#    题目逻辑：p = next_prime(S**16)
# ==========================================
# 注意 S**16 很大，需要用 gmpy2 处理大数运算
base_p = gmpy2.mpz(S) ** 16
p = int(gmpy2.next_prime(base_p))

# 验证 p 是否正确
if N % p == 0:
    print("[+] Successfully recovered p!")
    q = N // p
else:
    print("[-] Failed to recover p. Check parameters.")
    exit()

# ==========================================
# 5. 标准 RSA 解密
# ==========================================
e = 65537
phi = (p - 1) * (q - 1)
d = inverse(e, phi)

m = pow(c, d, N)
flag = long_to_bytes(m)

print("\n--------------------------------------------------")
print("Flag:", flag.decode())
print("--------------------------------------------------")
```

### easyRSA（利用 p 信息泄露 GCD 攻击）

![](https://pic1.imgdb.cn/item/692bc9e3291f309b79e8b598.png)

解题技巧先放前面：

1. **识别 GCD 攻击模式：**看到泄露信息 hint = m^17 (mod p)，必须立刻联想到 p 是 (m^17 - hint) 的因子

```python
from Crypto.Util.number import *
from secret import flag # 目标明文

# 1. 初始化和密钥生成
m = bytes_to_long(flag)  # 将 Flag 转换为巨大的整数 m
p = getPrime(1024)       # 生成第一个秘密素数 p (1024 bits)
q = getPrime(1024)       # 生成第二个秘密素数 q (1024 bits)
n = p * q                # RSA 模数 N (2048 bits，安全标准)

# 2. 核心漏洞：Hint 的泄露
# 提示 H 是明文 m 以极小的指数 17 对素数 p 取模的结果。
# 数学关系：hint ≡ m^17 (mod p)
# 这意味着 p 整除 (m^17 - hint)
hint = pow(m, 17, p)

# 3. 标准 RSA 加密
e = 65537                # 公钥指数 e (最常用的 Fermat 素数)
c = pow(m, e, n)         # 密文 c ≡ m^e (mod n)

# 4. 泄露给攻击者的信息
print("n =", n)          # 公钥模数 N (2048-bit)
print("e =", e)          # 公钥指数
print("c =", c)          # 密文
print("hint =", hint)    # 泄露信息 H (m^17 mod p)
```

我们从题目提供的两个基本关系开始：
$$
\begin{aligned}
&1:\ x\ =\ 11\ *\ d\ +\ 7\ *\ \phi(n)\\\\
&2:\ e\ *\ d\ \equiv 1\ (mod\ \ {\phi(n)})\\\\
&将\ RSA\ 关系转化为代数等式，引入一个未知整数\ r\\\\
&e\ *\ d\ =\ 1\ +\ r\ *\ \phi(n)
\end{aligned}
$$
我们的目标是消除未知数 d。最有效的方法是将**等式 1** 的两侧都乘以已知的公钥 e，从而引入 e * d 项，方便进行替换

将**等式 1** 两侧同乘 e：
$$
\begin{aligned}
&3:\ x\ *\ e=\ 11\ *\ (e\ *\ d)+\ 7\ *\ e\ *\phi(n)
\end{aligned}
$$
现在，我们将**等式 2** 代入**等式 3** 中的 (e * d) 项：
$$
\begin{aligned}
&3:\ x\ *\ e=\ 11\ *\ (1\ +\ r\ *\ \phi(n))+\ 7\ *\ e\ *\phi(n)
\end{aligned}
$$
现在，等式中已经成功消除了 d。我们进行代数整理，将所有含欧拉函数 n 的项归类，常数项移到左侧
$$
\begin{aligned}
&x\ *\ e=\ 11\ +\ 11\ *\ r\ *\ \phi(n)+\ 7\ *\ e\ *\phi(n)\\\\
&x\ *\ e\ -\ 11\ =\ 11\ *\ r\ *\ \phi(n)+\ 7\ *\ e\ *\phi(n)\\\\
&x\ *\ e\ -\ 11\ =\ (11\ *\ r\ +\ 7\ *\ e)\ *\phi(n)\\\\
&\phi(n)\ =\ \frac{x*e-11}{11*r+7*e}\\\\
\end{aligned}
$$
这个方程中，唯一剩下的未知数是整数 r

由于欧拉函数 n 必须是一个巨大的**整数**（通常 2048 位），因此分子必须能够被分母**整除**

所以直接爆破破解 r

```python
from Crypto.Util.number import *
import gmpy2
import sys

# =========================================================
# 步骤 1: 替换为题目中泄露的参数
# IMPORTANT: 请将这里的占位符替换为你实际的 CTF 数据！
# =========================================================
N = 15321211041844905603734344178124947500324300419514650914959277216026081094496518094622195813971694335738777589926626969243883848477814650916143749322154944235584863085124154540941941026813506509060939499627059712020664731558566028207969260861863294704292014958955493668692256998253634012942569080200336487172402729072437050952572508561453302097971258470685521456512378089846772560530301852104802168974905937732653119166440832834381675710869396094149006807933529429939569477709674581421481769103309376717894952118650888932952440197471338958967318775671821835706884032860123711415773758546392549257375305940969423099611  # RSA 模数 n
E = 65537  # 公钥指数 e (通常是 65537)
C = 14896093236493033914781929755936872928003725648997746598164823180134348743474984136539422027221313199599273430548738399424773586673404519182726589878322104929749149555906399158136445184378100079558203687049497943904275695897824656260657349522646553949766831267321006314984113971129230701131171378457086851261467999754137290017989201512492586108768533159551545321805463224339252886492732021354821330371600069958523522302729848548167244423902572054475396534469987383265867036041513161170273368613864180696427386890714264902686976581317435011139081192227958859641684254938165261747405568369502852705979424383731908971282  # 密文 c
X = 265060901898485540806769085700708185460124724747068797929982044073895401490880169847709049380530156090772787935089173201664711759633269693627724735457902114209008145932150728406880988293457762401679305297063608204632708505031098047582175011825482347052645324085149631658741807382378778694666759557421043250548432429798543553950625554307402164142007388940921309688918410535907564996075660231557340541491155676279511654970843992008027830570227549010293790074386638365293013298327534604995316180405779571245069623638693068707267840181413082202552862853411080755107836252852929279422343700808788459217261282790226013328915  # 泄露信息 x (x = 11*d + 7*phi(n))


# 我们可以从 r=1 开始，因为 r 必须是正整数
R_MAX = 100000


# =========================================================
# 步骤 2: 核心解题函数 - 枚举 r 求解 phi(n)
# =========================================================

def solve_modified_rsa(N, E, C, X, R_MAX):
    """
    根据公式 phi(n) = (X*E - 11) / (11*r + 7*E) 枚举 r，
    并验证结果是否为合法的 phi(n)。
    """

    # 公式分子 C_NUM = X*E - 11
    C_NUM = X * E - 11

    print(f"[*] 开始枚举 r (r_max={R_MAX})...")

    # r 必须为正整数
    for r in range(1, R_MAX + 1):
        # 公式分母 D_DEN = 11*r + 7*E
        D_DEN = 11 * r + 7 * E

        # 1. 整除性检查：判断分子是否能被分母整除
        if C_NUM % D_DEN == 0:

            # 找到潜在的 phi(n)
            phi_n = C_NUM // D_DEN
            print(f"[+] 找到潜在的 phi(n) 候选项 (r={r})")

            # 2. 合理性检查：phi(n) 必须小于 N
            if phi_n >= N:
                # 理论上不可能，如果出现说明数据有误，或 r_max 设置太小
                continue

            # 3. RSA 约束检查：判断 phi(n) 是否能用于分解 N
            # 我们知道：p + q = N - phi(n) + 1
            # 设 S = p + q
            S = N - phi_n + 1

            # 根据韦达定理，p, q 是二次方程 X^2 - S*X + N = 0 的根
            # 判别式 D = S^2 - 4*N 必须是一个完全平方数 (Perfect Square)
            D = S * S - 4 * N

            # 使用 gmpy2 检查 D 是否为完全平方数
            if gmpy2.is_square(D):
                print(f"[!!!] 成功找到正确的 phi(n)!")
                print(f"[!] r = {r}")
                print(f"[!] phi(n) = {phi_n}")

                # 4. 最终解密

                # 计算私钥 d = E^(-1) mod phi(n)
                d = inverse(E, phi_n)

                # 解密明文 m = C^d mod N
                m = pow(C, d, N)

                flag = long_to_bytes(m)

                print("\n==============================================")
                print(f"p + q = {S}")
                print(f"Private Key d = {d}")
                print(f"Decrypted Flag: {flag.decode()}")
                print("==============================================")
                return True  # 退出函数

    print("[-] 未能在设定的 R_MAX 范围内找到有效的 phi(n)，请尝试增大 R_MAX 或检查输入数据。")
    return False


if __name__ == "__main__":
    if N == ...:
        print("错误：请先在脚本顶部替换 N, C, X 的占位符！")
        sys.exit(1)

    solve_modified_rsa(N, E, C, X, R_MAX)
```

